<!--SaueracleOS by @SalatielSauer - Content Generation Toolset for Sauerbraten-->
<!--This is an incomplete remake of SaueracleOS (19/07/2025)-->
<!DOCTYPE html>
<html>
	<head>
		<!--<base href='SaueracleOS/v1.0'>-->
		<title>SaueracleOS</title>
		<link rel="icon" type="image/x-icon" href="saueracle.ico">
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/interactjs@1.10.27/dist/interact.min.js"></script>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/speed-highlight/core/dist/themes/dark.css">
		<style>
			@keyframes window_minimize {
				from {
					opacity: 1;
				}
				to {
					transform: translateY(100vh); /* move to the bottom of the viewport */
					opacity: 0;
				}
			}

			@keyframes window_close {
				0% {
					filter: grayscale(0);
				}
				50% {
					opacity: 1;
				}
				100% {
					opacity: 0;
					filter: grayscale(1);
				}
			}

			@keyframes loading {
				from {
					left: -200px;
					width: 30%;
				}
				50% {
					width: 30%;
				}
				70%{
					width: 70%;
				}
				80%{
					left: 50%;
				}
				95% {
					left: 120%;
				}
				to {
					left: 100%;
				}
			}

			@keyframes spin {
				from {
					transform: rotate(0deg);
				} to {
					transform: rotate(360deg);
				}
			}

			@keyframes flip {
				0%, 20%, 80%, 100% {
					transform: rotate(0deg);
				}
				50% {
					transform: rotate(180deg);
				}
			}

			/* Scrollbar by: GhostRider (https://codepen.io/GhostRider/pen/GHaFw) */
			::-webkit-scrollbar-track
			{
				-webkit-box-shadow: inset 0 0 6px rgba(1,1,1,1.3);
				background-color: #201d1a;
			}

			::-webkit-scrollbar
			{
				width: 12px;
				background-color: #201d1a;
			}

			::-webkit-scrollbar-thumb
			{
				border-radius: 2px;
				-webkit-box-shadow: inset 0 0 6px rgba(1,1,1,.3);
				background-color: #cf1b95;
			}

			::-webkit-scrollbar-corner { background-color: #201d1a; }
			::-webkit-scrollbar { cursor:pointer; }

			a:hover {
				color: #7fffa7;
			}

			a {
				color: aquamarine;
				text-decoration: none;
			}

			.app_window_loading { display:none; width:100%; height:4px; background:#1a1a1a; position:absolute; overflow:hidden; z-index: 1;}
			.app_window_loading::after { content:''; display:block; position:absolute; left:-200px; width:200px; height:4px; background:#4CAF50; animation:loading 2s linear infinite }

			body, html {
			    height: 100%;
			    margin: 0;
			    padding: 0;
			    background-color: black;
			}
			#desktop {
				background: url('https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/wallpaper.jpeg?raw=true') center/cover;
				height: calc(100vh - 40px)
			}
			.desktop_apps {
				display: grid;
				grid-template-columns: repeat(9, 100px);
				gap: 16px;
				grid-auto-rows: minmax(80px, auto);
				/* justify-content: center; */
				align-content: start;
				padding: 20px;
				overflow: auto;
				height: calc(100vh - 40px);
				font-family: sans-serif;
			}

			.desktop_app {
				width: 80px;
				height: 80px;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				cursor: pointer;
				transition: .2s;
				text-align: center;
				padding: 4px;
			}

			.desktop_app:hover {
			    transform: scale(1.1);
			    filter: brightness(1.2);
			}

			.desktop_app img {
				width: 48px;
				height: 48px;
				margin-bottom: 5px;
			}

			.desktop_app_title {
				color: #fff;
				text-shadow: 1px 1px 2px #000;
				font-size: 12px;
			}

			#toolbar {
				display: flex;
				align-items: center;
				padding: 10px;
				background-color: #333;
				color: white;
				position: relative;
				top: -57px;
				background: rgba(44, 0, 30, 0.8);
				z-index: 2;
			}

			.toolbar_icon, #button_start {
				background: none;
				border: none;
				cursor: pointer;
				padding: 5px;
				margin-right: 10px;
			}
			.toolbar_icon :hover, #button_start :hover, .app_window_header_buttons :hover {
				transform: scale(1.2);
			}

			.toolbar_icon_selected {
				outline-color: #8b14cd;
				outline-style: inset;
				background-color: #4f006ab0;
				box-shadow: 0px 0px 5px 0px #6e3159;
				filter: brightness(1.2);
			}

			.toolbar_subicon {
				background-color: #a718f652;
				border-radius: 5px;
				position: absolute;
				margin-left: -15px;
				margin-top: 10px;
				border-top-left-radius: 0px;
			}

			#button_start :hover {
				background-color: rgb(71 0 48 / 80%);
				border-radius: 40px;
			}

			#toolbar img {
				height: 24px;
				width: auto;
			}

			#desktop {
				position: relative;
				width: 100%;
				height: 100vh;
				overflow: hidden;
			}

			.app_window {
				top: 0;
				position: absolute;
				/*width: 300px;
				height: 200px;*/
				background: #242424;
				border: 1px solid rgba(44, 0, 30, 0.8);
				border-radius: 5px;
				overflow: hidden;
				resize: both;
				overflow: auto;
				box-sizing: border-box;
				min-height: 40px;
				min-width: 128px;
				box-shadow: 0 0 6px 0px #000000a3;
				transition: border-color 0.1s, opacity 0.1s;
				z-index: 1;
			}

			.app_window_content {
				overflow: auto;
				position: absolute;
				bottom: 0;
				left: 0;
				right: 0;
				top: 29px;
				margin: 6px;
				border-style: outset;
				border-color: #0000000f;
				color: white;
				font-family: sans-serif;
			}
			.app_window_header {
				display: flex;
				/* justify-content: space-between; */
				align-items: center;
				text-align: left;
				padding: 5px 10px;
				background: #4d0035;
				color: white;
				cursor: move;
				user-select: none;
				z-index: 1;
				position: absolute;
				width: -webkit-fill-available;
				width: -moz-available;
				font-family: sans-serif;
				line-break: anywhere;
			}

			.app_window_header_buttons {
			    position: absolute;
			    right: 0;
			    padding: 4px;
			    z-index: 1;
			}

			.app_window_header button, .app_window_header_buttons button {
				border: none;
				background: none;
				cursor: pointer;
			}

			.app_window_header img, .app_window_header_buttons img {
				height: 16px;
				width: 16px;
			}
			
			.app_window_icon {
				margin-right: 5px;
				border-radius: 15px;
				filter: drop-shadow(1px 1px 15px black);
			}

			.app_window_highlight {
				border-color: #a70073;
				outline: auto;
				outline-color: blueviolet;
				outline-style: solid;
				outline-width: 1px;
			}

			.app_window_minimize {
				animation: window_minimize 0.2s ease-in-out forwards;
			}
			.app_window_close {
				animation: window_close 0.2s ease-in-out forwards;
			}

			._app_chat_container {
				background-color: #181818;
				/* width: 512px; */
				/* height: 256px; */
				resize: auto;
				height: -webkit-fill-available;
				display: grid;
				border-bottom-right-radius: 20px;
			}

			._app_chat_status {
				color: antiquewhite;
				font-family: monospace;
				background-color: #00000030;
				font-size: smaller;
				padding: 5px;
				position: absolute;
				bottom: 40px;
				left: 0;
				user-select: none;
			}
			
			._app_chat_status_input {
				background-color: #333333;
				bottom: 42px;
				left: 3px;
				border-radius: 10px;
				border-bottom-left-radius: 0px;
				border-bottom-right-radius: 0px;
			}

			._app_chat_messages {
				position: relative;
				color: white;
				font-family: sans-serif;
				padding: 7px;
				overflow: auto;
				min-height: 250px;
			}

			._app_chat_other {
				background-color: #00000054;
				padding: 9px;
				max-width: fit-content;
				border-radius: 15px;
				border-top-left-radius: 0px;
				margin-bottom: 2px;
				/* align-items: center; */
				width: fit-content;
				/* float: left; */
				display: inline-block;
			}

			/*._app_chat_other strong {
				padding-right: 4px;
				margin-top: 3px;
			}*/
			._app_chat_other ._app_chat_other_name {
				padding-right: 4px;
				margin-top: 3px;
				background-color: #24242457;
				padding: 2px;
				border-radius: 5px;
				display: table;
				color: #c2fff7;
			}
			._app_chat_other_name_timestamp {
				color: grey;
				font-size: small;
				margin: 5px;
				font-family: monospace;
			}
			._app_chat_me {
				background-color: #002622;
				padding: 8px;
				max-width: 256px;
				border-radius: 15px;
				border-bottom-right-radius: 0px;
				float: right;
				overflow-wrap: anywhere;
				border-style: solid;
				border-width: 1px;
				border-color: #0000005e;
				margin-bottom: 2px;
			}

			._app_chat_textarea {
				place-self: flex-end;
				flex: auto;
				background-color: #333333;
				border-style: none;
				margin: 3px;
				resize: none;
				color: white;
				font-family: sans-serif;
				/* min-width: -webkit-fill-available; */
				padding-left: 5px;
				padding-top: 5px;
			}

			._app_chat_textarea:focus-visible {
			    outline-color: #5e5e5e;
			    outline-style: solid;
			}
			
			._app_button {
				background-color: #7289da;
				border: none;
				color: #fff;
				padding: 8px 15px;
				font-size: 14px;
				cursor: pointer;
				border-radius: 3px
			}

			._app_input_button {
				cursor: pointer;
				background-color: #002622;
				color: white;
				border-width: 1px;
				border-bottom-right-radius: 20px;
			}
			
			._app_button:hover {
				background-color: #00443d;
			}

			._app_button:disabled {
				background-color: #5c6170;
				color: #c9c9c9;
				pointer-events: none;
				filter: grayscale(1);
			}

			._app_button_small {
				padding: 3px;
				background-color: #008061;
				font-size: small;
			}

			._detached {
				z-index: 1;
				position: absolute;
				right: 0px;
				top: 0px;
			}

			._detached ._app_button {
				margin-left: 5px;
			}

			:root {
				--editor-height: 100%;
				--editor-width: 100%;
			}

			.texteditor_editor {
				background: transparent;
				caret-color: white;
				color: transparent;
				outline: none;
				transition: border-color 0.2s;
				white-space: pre;
				z-index: 1;
				border-style: none;
				word-wrap: normal;
			}

			.texteditor_editor:focus {
				border-color: #444242;
			}

			.texteditor_editor::selection {
				background-color: #ed143db5;
				color: white;
			}

			.texteditor_pre,
			.texteditor_editor {
				overflow: auto;
			}

			.texteditor_code {
				color: #bfbfbf;
				filter: hue-rotate(310deg) saturate(3);
				pointer-events: none;
				text-shadow: 0px 1px 3px black;
				padding-bottom: 4%;
				outline-offset: -2px;
			}

			.texteditor_code,
			.texteditor_editor {
				font-family: monospace;
				font-size: 15px;
				display: block;
				height: var(--editor-height);
				max-height: var(--editor-height);
				max-width: var(--editor-width);
				min-width: var(--editor-width);
				position: absolute;
				resize: none;
				width: var(--editor-width);
				text-wrap: balance;
			}

			.extra_spin {
				display: none;
			}

			.extra_spin:last-of-type {
				display: inline-block;
				animation: spin 2s linear infinite;
			}

			.extra_flip {
				display: none;
			}

			.extra_flip:last-of-type {
				display: inline-block;
				animation: flip 4s linear infinite;
			}

			/* out-of-place highlight (shj) hack */
			[class*=shj-lang-] {
				padding: 15px;
				margin: 0px;
				left: 0px;
				top: 0px;
			}
			[class*=shj-lang-]>div {
				display: block;
				max-height: 100%;
				overflow: auto;
				text-wrap: balance;
			}
			[class*=shj-lang-]>div::-webkit-scrollbar,
			[class*=shj-lang-]>div::-webkit-scrollbar-track,
			[class*=shj-lang-]>div::-webkit-scrollbar-thumb {
				background: transparent;
				background-color: transparent;
				-webkit-box-shadow: unset;
			}

		</style>
	</head>

	<body>
		<div id='desktop'>
			<div id='desktop_apps_list'></div>
		</div>

		<div id="toolbar">
			<div id="open_apps">
		</div>
		
		<script type="module">
			import { highlightElement } from 'https://cdn.jsdelivr.net/gh/speed-highlight/core/dist/index.js'
			import { detectLanguage } from 'https://cdn.jsdelivr.net/gh/speed-highlight/core/dist/detect.js'

			window.highlightElement = highlightElement;
			window.detectLanguage = detectLanguage;
		</script>

		<script>
			// hardcoded paths for easy modding
			const _api_endpoint_chatgenerator = 'https://websim.ai/api/cube2sauerbraten-chat-channel';
			const _api_endpoint_filegenerator = 'https://websim.ai/api/cube2sauerbraten-saueracleos-file-explorer';
			const _api_endpoint_functiongenerator = 'https://websim.ai/api/minified-javascript-function-body-generator';
			const _api_endpoint_htmlgenerator = 'https://websim.ai/api/optimized-html-generator-modern';
			const _api_endpoint_gametracker_server = 'https://sauertracker.net/api/v2/server';
			const _api_endpoint_gametracker_servers = 'https://sauertracker.net/api/v2/servers';
			const _api_endpoint_gametracker_player = 'https://sauertracker.net/api/v2/player';
			const _api_endpoint_gametracker_mapshots = 'https://sauertracker.net/images/mapshots';
			const _icon_back = 'https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/folder_return.png?raw=true';
			const _icon_chat = 'https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/cubicle.jpeg?raw=true';
			const _icon_close = 'https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/exit.jpeg?raw=true';
			const _icon_fail = 'https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/fail.gif?raw=true';
			const _icon_file = 'https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/file.png?raw=true';
			const _icon_file_empty = 'https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/file_new.png?raw=true';
			const _icon_folder = 'https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/folder.png?raw=true';
			const _icon_folder_empty = 'https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/folder_new.png?raw=true';
			const _icon_info = 'https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/info.jpeg?raw=true';
			const _icon_josias = 'https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/josias.png?raw=true';
			const _icon_jsocta = 'https://raw.githubusercontent.com/SalatielSauer/OGZ-Editor/master/images/icon-192.png?raw=true';
			const _icon_main = 'https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/saueracle.png?raw=true';
			const _icon_minimize = 'https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/minimize.png?raw=true';
			const _icon_refresh = 'https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/refresh.png?raw=true';
			const _icon_server = 'https://github.com/SalatielSauer/SaueracleOS/blob/main/assets/server.jpeg?raw=true';

			const _app_name = 'SaueracleOS';
			const _app_version = '2.0';
			const _app_subject_name = 'Cube 2 Sauerbraten';
			const _app_subject_name_short = 'Sauerbraten';

			const _nelement = (name) => document.createElement(name);
			const _qelement = (name) => document.querySelector(name);

			class DesktopApps {
				constructor(parent) {
					this.parent = (typeof parent == 'string') ? this._qelement(parent) : parent;
					this.toolbar = this._qelement('#open_apps') || undefined;
					this.icons = [];
					this.windows = [];
					this.toolbar_icons = [];
				}

				_qelement(selector) {
					return document.querySelector(selector);
				}

				_nelement(tag) {
					return document.createElement(tag);
				}

				addWindow(title = 'Default App', body, iconImage = '', width = 128, height = 64, pos_x = 0, pos_y = 0, force = false) {
					let existingWindow = this.windows.find(w => w.title === title && (!w.open || force));
					if (existingWindow) {
						this.toggleWindowDisplay(this.windows.indexOf(existingWindow));
						existingWindow.body.focus();
						this.updateToolbar();
						return;
					}

					let div_window = this._nelement('div');
					div_window.className = 'app_window';
					div_window.style.position = 'absolute';
					div_window.style.width = `${width}px`;
					div_window.style.height = `${height}px`;

					// calculate initial position with boundary checks
					let [adjustedX, adjustedY] = this.adjustPosition(pos_x - (width / 2), pos_y - 16, width, height);

					div_window.style.transform = `translate(${adjustedX}px, ${adjustedY}px)`;
					div_window.setAttribute('pos_x', adjustedX);
					div_window.setAttribute('pos_y', adjustedY);

					div_window.setAttribute('force', force);

					/*div_window.addEventListener('mouseenter', () => {
						div_window.style.opacity = 1
					})
					div_window.addEventListener('mouseleave', () => {
						div_window.style.opacity = 0.95
					})*/

					div_window.addEventListener('click', (e) => {
						//console.log(appwindow)
						let appwindow_index = this.windows.indexOf(appwindow)
						this.updateToolbar();
						//console.log("window:", appwindow)
						if (appwindow_index == -1) return;
						this.toolbar_icons[appwindow_index].classList.add('toolbar_icon_selected')
					})

					div_window.addEventListener('resize', () => {
						let dump_refresh = div_window.scrollHeight;
					})

					let div_window_header = this._nelement('div');
					div_window_header.className = 'app_window_header';

					let image_window_icon = this._nelement('img');
					image_window_icon.src = iconImage;
					image_window_icon.className = 'app_window_icon'

					let span_window_title = this._nelement('span');
					span_window_title.className = 'app_window_title';
					span_window_title.innerHTML = title;

					let div_window_header_buttons = this._nelement('div');
					div_window_header_buttons.className = 'app_window_header_buttons';

					let button_refresh = this._nelement('button');
					button_refresh.className = 'button_refresh';
					button_refresh.addEventListener('click', () => {
						let index_to_remove = this.windows.findIndex(w => w.body === div_window);
						console.log('refresh', appwindow.onrefresh, this.lastIconClick, index_to_remove);
						if (appwindow.onrefresh != false) {
							appwindow.onrefresh();
						} else {
							if (this.lastIconClick) {
								this.lastIconClick();
								this.removeWindows(index_to_remove);
							} else {
								button_refresh.style.display = 'none';
							}
						}
					});
					
					let image_refresh_button = this._nelement('img');
					image_refresh_button.src = _icon_refresh;
					button_refresh.appendChild(image_refresh_button);

					let button_min = this._nelement('button');
					button_min.className = 'button_minimize';
					button_min.addEventListener('click', () => this.toggleWindowDisplay(this.windows.indexOf(appwindow)));

					let image_min_button = this._nelement('img');
					image_min_button.src = _icon_minimize;
					button_min.appendChild(image_min_button);

					let button_close = this._nelement('button');
					button_close.className = 'button_close';
					button_close.addEventListener('click', () => {
						const index = this.windows.findIndex(w => w.body === div_window);
						div_window.classList.add('app_window_close');
						setTimeout(() => {
							this.removeWindows(index);
						}, 200)
					    
					});

					let image_close_button = this._nelement('img');
					image_close_button.src = _icon_close;
					button_close.appendChild(image_close_button);

					let div_window_content = this._nelement('div');
					div_window_content.className = 'app_window_content';

					let div_window_loading = this._nelement('div');
					div_window_loading.className = 'app_window_loading';
					div_window_content.appendChild(div_window_loading);

					div_window_content.appendChild(body);

					div_window_header.appendChild(image_window_icon);
					div_window_header.appendChild(span_window_title);
					div_window_header_buttons.appendChild(button_refresh);
					div_window_header_buttons.appendChild(button_min);
					div_window_header_buttons.appendChild(button_close);
					if (!force) {
						div_window_header.appendChild(div_window_header_buttons);
					}
					div_window.appendChild(div_window_header);
					div_window.appendChild(div_window_content);

					let appwindow = {
						title,
						open: true,
						body: div_window,
						iconImage,
						subIcon: false,
						loading: (state = false) => {div_window_loading.style.display = state ? 'block' : 'none'},
						onrefresh: false,
					};

					this.windows.push(appwindow);
					div_window.focus();
					this.drawWindows(this.windows.length - 1);
					this.updateToolbar();
					return appwindow;
				}

				removeWindows(index = -1) {
					if (index === -1) {
						this.windows.forEach(win => win.body.remove());
						this.windows = [];
					} else {
						this.windows[index].body.remove();
						this.windows.splice(index, 1);
					}
					this.updateToolbar();
				}

				drawWindows(index = -1) {
					if (index === -1) {
						this.windows.forEach(win => {
							if (win.open) {
								this.parent.appendChild(win.body);
								console.log("loading", win.title, win.loading)
								if (win.loading) {
									win.body.querySelectorAll('.app_window_loading')[0].style.display = 'block';
								} else {
									win.body.querySelectorAll('.app_window_loading')[0].style.display = 'none';
								}
							}
						});
					} else if (this.windows[index]) {
						this.parent.appendChild(this.windows[index].body);
					}
				}


				toggleWindowDisplay(index) {
					if (this.windows[index]) {
						const currentDisplay = this.windows[index].body.style.display;
						this.windows[index].open = currentDisplay === 'none';
						if (!this.windows[index].open) {
							this.windows[index].body.classList.add('app_window_minimize')
						}

						setTimeout(() => {
							this.windows[index].body.style.display = currentDisplay === 'none' ? 'block' : 'none';
							this.windows[index].body.className = 'app_window';
						}, !this.windows[index].open ? 500 : 0)

					}
					

				}

				drawIcons(list = this.icons) {
					this.parent.innerHTML = '';
					this.parent.appendChild(this.getIcons(list));
				}

				getIcons(list = this.icons) {
					const icons = this._nelement('div');
					icons.className = 'desktop_apps';

					list.forEach(icon => {
						let div_icon = this._nelement('div');
						div_icon.className = 'desktop_app';
						div_icon.addEventListener('click', (event) => icon.onclick(event));

						let img_icon = this._nelement('img');
						img_icon.src = icon.image;

						let div_title = this._nelement('div');
						div_title.className = 'desktop_app_title';
						div_title.textContent = icon.title;

						div_icon.appendChild(img_icon);
						div_icon.appendChild(div_title);

						icons.appendChild(div_icon);
					});

					return icons;
				}

				addIcon(title = 'Default App', image = '', onclick = () => {}) {
					// store the icon data with an onclick that includes the icon image URL
					this.icons.push({ title, image, onclick: (e) => {
						onclick(event, image);
						this.lastIconClick = () => onclick(event, image);
					}});
				}

				updateToolbar() {
					if (!this.toolbar) return;
					this.toolbar_icons = [];
					this.toolbar.innerHTML = '';
					this.windows.forEach((win, index) => {
						//if (win.open) {
							let button_toolbar_icon = this._nelement('button');
							button_toolbar_icon.addEventListener('click', () => {
								if (!win.open && win.body.style.display == 'block') {win.body.style.display = 'none'}
								this.toggleWindowDisplay(index);
								win.body.focus()
								if (win.open) {
									let currentSelected = this.toolbar.querySelectorAll('.toolbar_icon_selected');
									if (currentSelected[0]) {
										currentSelected[0].classList.remove('toolbar_icon_selected')
									}
									button_toolbar_icon.classList.add('toolbar_icon_selected')
								}
							});
							button_toolbar_icon.className = 'toolbar_icon';

							// handle mouse enter to add outline
							button_toolbar_icon.addEventListener('mouseenter', () => {
								win.body.classList.add('app_window_highlight');
								if (!win.open) {win.body.style.display = 'block'}
							});

							// handle mouse leave to remove outline
							button_toolbar_icon.addEventListener('mouseleave', () => {
								win.body.classList.remove('app_window_highlight');
								if (!win.open) {win.body.style.display = 'none'}
							});

							let icon = this._nelement('img');
							icon.src = win.iconImage;  // use the icon image from the window object
							icon.title = win.title;  // tooltip showing the window title
						
							button_toolbar_icon.appendChild(icon);

							if (win.subIcon) { // extra smaller icon that shows over the main icon.
								let subicon = this._nelement('span');
								subicon.className = 'toolbar_subicon';
								subicon.textContent = win.subIcon;
								button_toolbar_icon.appendChild(subicon);
							}

							this.toolbar.appendChild(button_toolbar_icon);
							this.toolbar_icons.push(button_toolbar_icon);
						//}
					});
				}

				adjustPosition(x, y, width, height) {
					// adjust for right and left boundaries
					x = Math.min(Math.max(x, 0), window.innerWidth - width);
					
					// adjust for bottom and top boundaries
					y = Math.min(Math.max(y, 0), (window.innerHeight-64) - height);
					
					return [x, y];
				}

			}

			class ChatWindow {
				constructor(classname) {
					this.div_chat = document.createElement('div');
					this.div_chat.className = `_app_chat_container ${classname}`;

					this.div_chat_messages = document.createElement('div');
					this.div_chat_messages.className = '_app_chat_messages';

					this.div_status = document.createElement('div');
					this.div_status.className = `_app_chat_status`;


					this.textarea_chat = document.createElement('textarea');
					this.textarea_chat.className = '_app_chat_textarea';
					this.textarea_chat.placeholder = 'âž¤ type your message here';

					this.button_send = document.createElement('button');
					this.button_send.className = '_app_button';
					this.button_send.textContent = 'Send';

					this.div_chat.appendChild(this.div_chat_messages);

					let div_input_container = document.createElement('div');
					div_input_container.style.display = 'flex';
					div_input_container.style.alignSelf = 'flex-end';

					div_input_container.appendChild(this.div_status);
					div_input_container.appendChild(this.textarea_chat);
					div_input_container.appendChild(this.button_send);
					//this.div_chat.appendChild(this.textarea_chat);
					//this.div_chat.appendChild(this.button_send);
					this.div_chat.appendChild(div_input_container);
					this.parent = this.div_chat_messages;

					this.messages = []
				}

				showStatus(content = false, inputStatus = false) {
					if (content) {
						this.div_status.innerHTML = content;	
					}
					this.div_status.style.display = content ? 'block' : 'none';
					if (inputStatus) {
						this.div_status.classList.add('_app_chat_status_input')
					} else {
						this.div_status.classList.remove('_app_chat_status_input')
					}
				}

				addBreaks(element, count) {
					for (let i = 0; i < count; i++) {
						element.appendChild(document.createElement('br'));
					}
				}

				/*pushMessage(author, message, element = this.parent, timestampOfsset = 0) {
					let span = document.createElement('span');
					span.className = (author == -1 ? '_app_chat_me' : '_app_chat_other');
					if (message instanceof HTMLElement) {
						span.appendChild(message)
					} else {
						// calculate the timestamp considering the offset
						let date = new Date();
						date.setSeconds(date.getSeconds() + timestampOfsset); // adjust the time by the offset in seconds
						let timestamp = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); // get adjusted time in human-readable format
						span.innerHTML = `${author == -1 ? '' : `<span class='_app_chat_other_name'><strong>${author}</strong><span class='_app_chat_other_name_timestamp'>${timestamp}</span></span>`}<span>${message}</span>`
					}
					this.messages.push({author, span});
					if (author == -1) { this.addBreaks(element, 2) } else { this.addBreaks(element, 1) }
					element.appendChild(span);
					element.scrollTop = element.scrollHeight;
					if (author == -1) { this.addBreaks(element, 2) }
					return span;
				}*/

				pushMessage(author, message, element = this.parent, timestampOfsset = 0) {
					let span = document.createElement('span');
					span.className = (author == -1 ? '_app_chat_me' : '_app_chat_other');
					const username = author; // or adjust as needed

					//const fileRegex = /([a-zA-Z0-9_\-\.]+?\.[a-zA-Z0-9]{1,8})/g;
					// must only match file extensions (texts, images, .ogz, js, html, css, etc.

					const fileRegex = /([a-zA-Z0-9_\-\.]+?\.(jsocta|txt|js|html|css|ogz|cfg|png|jpg|jpeg|gif|webp|bmp|exe))/g;
					
					const replacer = (match, filename) => {
						const filePath = `cubicle/${username}/${filename}`;
						return `<span class='_app_chat_file'
							style="color:#fd45c4;cursor:pointer;text-decoration:underline;"
							onclick="(function(event){
								event.stopPropagation();
								const period = chat_flow.getContext({pastCount:5, futureCount:5});
								const contextMessages = [
									...period.past,
									period.anchor,
									...period.future
								].filter(Boolean);
								let context = contextMessages.map(m => m.name + ': ' + m.message).join(' ');
								_loopfiles_generateFile('${filePath}', context, event, () => {
									saueracle_explorer.openFolder('cubicle/${username}');
									_josias_openWithLoopfiles('cubicle/${username}', event);
								});
							})(event)"
							>${filename}</span>`;
					};

					if (message instanceof HTMLElement) {
						span.appendChild(message);
					} else {
						let date = new Date();
						date.setSeconds(date.getSeconds() + timestampOfsset);
						let timestamp = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

						let processedMessage = message;
						if (author != -1) {
							// Only do file replacement if author != -1
							processedMessage = message.replace(fileRegex, replacer);
						}
						
						span.innerHTML = `${
							author == -1 ? '' : `<span class='_app_chat_other_name'><strong>${author}</strong><span class='_app_chat_other_name_timestamp'>${timestamp}</span></span>`
						}<span>${processedMessage}</span>`;
					}

					this.messages.push({author, span});
					if (author == -1) { this.addBreaks(element, 2) } else { this.addBreaks(element, 1) }
					element.appendChild(span);
					element.scrollTop = element.scrollHeight;
					if (author == -1) { this.addBreaks(element, 2) }
					return span;
				}


				drawMessages(element = this.parent) {
					element.innerHTML = ``;
					this.messages.forEach(m => {
						element.appendChild(m.span);
						if (m.author == -1) {
							this.addBreaks(element, 2)
						}
					})
				}

				lastMessageBy(author) {
					for (let i = this.messages.length - 1; i >= 0; i--) {
						if (this.messages[i].author === author) {
							return this.messages[i].span.lastChild;
						}
					}
					return null;
				}

			}

			class ChatFlow {
				constructor() {
					this.batches = new Map();
					this.readyQueue = [];
					this.sending = false;
					this.typingUsers = new Set();
					this.sentMessages = [];
					this.allPending = [];
					this.ontypingListeners = [];

					this.onSilenceListeners = [];
					this.silenceTimer = null;
					this.silenceTimeoutSec = 50;
				}

				addToQueue({ name, message, onSend }) {
					const nowSec = Math.floor(Date.now() / 1000);

					const msgObj = { name, message, onSend, _pending: true };
					this.allPending.push(msgObj);

					this._resetSilenceTimer();

					if (!this.batches.has(nowSec)) {
						this.batches.set(nowSec, []);
						setTimeout(() => {
							this.processBatch(nowSec);
						}, 0);
					}
					this.batches.get(nowSec).push(msgObj);
				}

				async processBatch(batchSec) {
					const batch = this.batches.get(batchSec);
					if (!batch) return;

					for (let i = 0; i < batch.length;) {
						const msgObj = batch[i];
						// If instaSend already sent it, skip
						if (!msgObj._pending) {
							batch.splice(i, 1);
							continue;
						}
						await this.simulateTyping(msgObj);
						if (msgObj._pending) {
							this.readyQueue.push(msgObj);
							this.startSender();
						}
						if (batch[i] === msgObj) i++;
						if (i < batch.length) {
							const randomGap = 2000 + Math.random() * 5000;
							await this.delay(randomGap);
						}
					}
					this.batches.delete(batchSec);
				}

				async simulateTyping(msgObj) {
					if (!msgObj._pending) return; // instaSend might have sent it

					this.typingUsers.add(msgObj.name);
					this.emitTyping();
					const chars = msgObj.message.length;
					const msPerChar = 100 + Math.random() * 60;
					const totalDelay = Math.floor(chars * msPerChar);

					await this.delay(totalDelay);
					this.typingUsers.delete(msgObj.name);
					this.emitTyping();
				}

				async startSender() {
					if (this.sending) return;
					this.sending = true;

					while (this.readyQueue.length > 0) {
						const msgObj = this.readyQueue.shift();
						// InstaSend might have sent it already
						if (!msgObj._pending) continue;
						this.actuallySend(msgObj);
						const globalGap = 5000 + Math.random() * 5000;
						await this.delay(globalGap);
					}
					this.sending = false;
				}

				actuallySend(msgObj) {
					if (!msgObj._pending) return;
					msgObj._pending = false;

					this.sentMessages.push({
						name: msgObj.name,
						message: msgObj.message,
						sentAt: new Date()
					});
					this.typingUsers.delete(msgObj.name);
					this.emitTyping();

					this._resetSilenceTimer();

					if (typeof msgObj.onSend === "function") {
						msgObj.onSend(msgObj);
					}
				}

				delay(ms) {
					return new Promise(res => setTimeout(res, ms));
				}

				get typingStatus() {
					const users = Array.from(this.typingUsers);
					if (users.length === 0) {
						return "";
					} else if (users.length === 1) {
						return `${users[0]} is typing..`;
					} else if (users.length === 2) {
						return `${users[0]} and ${users[1]} are typing..`;
					} else {
						return `${users[0]}, ${users[1]} and others are typing..`;
					}
				}

				// Instantly send the first `count` unsent messages, skipping all delays and typing
				instaSend(count) {
					let sent = 0;
					for (let msgObj of this.allPending) {
						if (msgObj._pending && sent < count) {
							this.actuallySend(msgObj);
							sent++;
						}
						if (sent >= count) break;
					}
				}

				// Register a callback for ontyping events
				ontyping(callback) {
					if (typeof callback === "function") {
						this.ontypingListeners.push(callback);
					}
				}

				// Internal: Call all listeners when typingUsers changes
				emitTyping() {
					const status = this.typingStatus;
					for (const cb of this.ontypingListeners) {
						cb(status, Array.from(this.typingUsers));
					}
				}

				setSilenceTimeout(sec) {
					this.silenceTimeoutSec = sec;
				}

				_resetSilenceTimer() {
					if (this.silenceTimer) clearTimeout(this.silenceTimer);
					this.silenceTimer = setTimeout(() => {
						this.emitSilence();
					}, this.silenceTimeoutSec * 1000);
				}
			
				onsilence(callback) {
					if (typeof callback === "function") {
						this.onSilenceListeners.push(callback);
					}
				}
			
				emitSilence() {
					for (const cb of this.onSilenceListeners) {
						cb();
					}
				}

				getContext({ pastCount = 3, futureCount = 3, anchorIndex } = {}) {
					const sent = this.sentMessages;
					const pending = this.allPending.filter(msg => msg._pending);

					// By default, anchor on latest sent message
					const anchorIdx = anchorIndex !== undefined ? anchorIndex : sent.length - 1;
					const past = sent.slice(Math.max(0, anchorIdx - pastCount), anchorIdx);
					const anchor = sent[anchorIdx] || null;
					const future = pending.slice(0, futureCount);

					return {
						past,      // Array of past sent message objects
						anchor,    // The anchor message (sent)
						future     // Array of upcoming (pending) message objects
					};
				}
			}


			const chat_flow = new ChatFlow();

			class APIFetch {
				constructor(url) {
					this.url = url;
					this.onfirstresponse = () => {};
					this.onlastresponse = () => {};
					this.onerror = (e) => {
						console.error('Failed at APIFetch', url, e);
					};
					this.get = () => {
						fetch(this.url)
							.then(fr => this.onfirstresponse(fr))
							.then(lr => this.onlastresponse(lr))
							.catch(err => this.onerror(err));
					};
				}

				async post(message) {
					const payload = {
						messages: [
							{ role: "system", content: message },
							{ role: "user", content: "Please follow exactly the instructions." }
						],
						json: true
					};

					try {
						const completion = await websim.chat.completions.create(payload);
						// Use .content if it's what you want; adjust as needed
						let firstResult = (typeof this.onfirstresponse === "function")
							? this.onfirstresponse(completion)
							: completion;

						if (firstResult instanceof Promise) firstResult = await firstResult;

						if (typeof this.onlastresponse === "function") {
							this.onlastresponse(firstResult);
						}
					} catch (err) {
						this.onerror(err);
					}
				}
			}


			class APIFetchContextual {
				constructor(url) {
					this.url = url;
					this.onerror = (e) => {
						console.error('Failed at APIFetch', this.url, e);
					};
				}

				// Default handler for the first response
				handleFirstResponse(response) {
					// For websim, this will just be the response object
					return response; 
				}

				// Default handler for the last response
				handleLastResponse(response, callback) {
					if (callback) {
						return callback(response);
					} else {
						console.log('Last response received:', response);
					}
				}

				// Default error handler
				handleError(error) {
					console.error('Error in APIFetch:', error);
				}

				// General function to use with the new websim API
				async fetchWithOptions(payload, onFirstResponse, onLastResponse, onError) {
					try {
						const completion = await websim.chat.completions.create(payload);
						let firstResult = onFirstResponse ? onFirstResponse(completion) : this.handleFirstResponse(completion);

						if (firstResult instanceof Promise) firstResult = await firstResult;
						if (onLastResponse) onLastResponse(firstResult);
					} catch (err) {
						(onError || this.handleError)(err);
					}
				}

				async get(onFirstResponse, onLastResponse, onError) {
					try {
						const response = await fetch(this.url, {
							method: 'GET',
							headers: {
								'Accept': 'application/json'
							}
						});

						if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

						const data = await response.json();

						let firstResult = onFirstResponse ? onFirstResponse(data) : this.handleFirstResponse(data);

						if (firstResult instanceof Promise) firstResult = await firstResult;
						if (onLastResponse) onLastResponse(firstResult);
					} catch (err) {
						(onError || this.handleError)(err);
					}
				}

				async post(message, onFirstResponse, onLastResponse, onError) {
					const payload = {
						messages: [
							{ role: "system", content: message },
							{ role: "user", content: `Proceed as instructed. Random Seed: ${Math.floor(Math.random() * 1000000)}, time: ${new Date().toDateString()}, OS: SaueracleOS.` }
						],
						json: true
					};
					await this.fetchWithOptions(payload, onFirstResponse, onLastResponse, onError);
				}
			}


			class TreeExplorer {
				constructor() {
					this.tree = {
						name: _app_name,
						type: 0,
						description: `${_app_name} System Files.`,
						child: [
							{
								name: _app_subject_name_short,
								type: 0,
								description: `${_app_subject_name} related files.`,
								child: [
									{
										name: 'scripts',
										type: 0,
										description: `${_app_subject_name} .cfg files, handy gameplay scripts and mods.`,
										child: []
									}
								]
							},
							{
								name: 'âš Cube Engine 3âš ',
								type: 0,
								description: 'Top Secret source code of Cube Engine 3 future project, based on quantum technology, contains the src folder, bin, docs, a todo list etc',
								child: []
							},
							{
								name: 'readme.txt',
								type: 1,
								description: `a file containing info about how ${_app_name} works, its on-the-fly interface/content generation, and a warning that all files and folders in LoopFiles are hallucinated (explain what this means). (at the end of the text make sure to indicate that even this file was generated and may not be 100% accurate). avoid over-dramatic claims such as "realistically" or "advanced AI"`,
								content: ''
							},
							{
								name: 'JSOCTA',
								type: 0,
								description: '',
								child: [
									{
										name: 'jsocta_sample.jsocta', type: 1, description: '',
										content: `// jsocta_sample.jsocta by @SalatielSauer\n/*\nFiles created by Josias The Mapper (.JSOCTA) will be mirrored in this folder. These files can be executed to generate the JSON data used by JSOCTA to assemble the .OGZ file.\n\nYou can run these files using the \"Compile\" button. JSOCTA will attempt to generate the .OGZ file from their output and provide it for you to download.\n\nMaps can be loaded in your Sauerbraten client by performing the following steps:\n\t1. Place the .OGZ files in the packages/base folder of your Sauerbraten.\n\t2. Use the /coop command followed by the name of the .OGZ file in the game console to load the map.\n*/\n\n// Modify the functions below to change the aspects of the .OGZ file:\n\nmapvars({\n\t\"maptitle\": \"Untitled Map by ${_app_name}\",\n\t\"skyboxcolour\": [0, 0, 0]\n})\n\nentities([\n\t{\"x\": 516, \"y\": 516, \"z\": 560, \"t\": 2, \"at1\": 23}, // carrot mapmodel (t: 2)\n\t{\"x\": 516, \"y\": 516, \"z\": 560, \"t\": 3, \"at0\": 90}  // playerstart (t: 3)\n])\n\n/*\nYou can use helper functions to generate arrays and objects:\n_addGround(texture) // returns an [array] containing four 512x512 cubes with given texture.\n_addCube(x, y, z, texture, gridpower) // returns an {object} containing a single cube with given properties.\n_addText(text, x, y, z, texture, gridpower, rotate) // returns an [array] containing cubes that form a given text.\n*/\ngeometry(()=>{\n\tlet cubes = _addGround(6);\n\tlet texture = 5;\n\tlet gridpower = 3;\n\n\tfor (let i = 0; i <= 5; i += 1) {\n\t\tcubes.push(_addCube(512, 512, 512 + (1 << gridpower)*i, texture, gridpower))\n\t}\n\treturn cubes;\n})`
									},
									{
										name: 'customizable_torus.jsocta', type: 1, description: '',
										content: `/*adjust the variables below and compile the ogz to see the changes in the map in game ðŸ©*/\nconst radius = 128;\nconst tubeRadius = 32;\nconst segments = 64;\nconst tubularSegments = 256;\nconst textures = [1, 6, 831, 832, 833, 834];\n\nconst result = [];\n\ngeometry(()=>{\n\tfor (let i = 0; i <= tubularSegments; i++) {\n\t\tconst u = (i / tubularSegments) * Math.PI * 2;\n\t\tfor (let j = 0; j <= segments; j++) {\n\t\t\tconst v = (j / segments) * Math.PI * 2;\n\t\t\tconst x = (radius + tubeRadius * Math.cos(v)) * Math.cos(u);\n\t\t\tconst y = (radius + tubeRadius * Math.cos(v)) * Math.sin(u);\n\t\t\tconst z = tubeRadius * Math.sin(v);\n\t\t\tconst texture = textures[Math.floor(Math.random() * textures.length)];\n\t\t\t\n\t\t\tresult.push(_addCube(\n\t\t\t\tMath.round(512 + x),\n\t\t\t\tMath.round(512 + y),\n\t\t\t\tMath.round(512 + z),\n\t\t\t\ttexture\n\t\t\t));\n\t\t}\n\t}\n\treturn result;\n})`
									},
									{
										name: 'terrain_generator.jsocta', type: 1, description: '',
										content: `/*request: 'I want a terrain generator with customizable parameters'*/\nmapvars({\"skybox\":\"penguins/yonder\",\"maptitle\":\"\\f6Map generated by bot \\f8Josias \\f6from \\f8${_app_name} \\f6(\\f5websim.ai/@SalatielSauer\\f6) using \\f8102357 \\f6cubes. \\n>>\\f8Prompt: \\f7 \\\"I want a terrain generator with customizable parameters\\\"\"})\ngeometry(()=>{\nconst generateTerrain = (size = 164, height = 32, roughness = 0.5, texture = 2) => {\n  const terrain = [];\n  const noise = (x, y) => {\n    let n = 0;\n    let a = 1;\n    let f = 1;\n    for (let i = 0; i < 8; i++) {\n      n += a * Math.sin((x * f) / size) * Math.cos((y * f) / size);\n      a *= roughness;\n      f *= 2;\n    }\n    return n;\n  };\n\n  for (let x = 0; x < size; x++) {\n    for (let y = 0; y < size; y++) {\n      const h = Math.floor((noise(x, y) + 1) * 0.5 * height);\n      for (let z = 0; z <= h; z++) {\n        terrain.push(_addCube(\n          Math.floor(512 - size / 2 + x),\n          Math.floor(512 - size / 2 + y),\n          Math.floor(512 - height / 2 + z),\n          texture\n        ));\n      }\n    }\n  }\n\n  return terrain;\n};\n\nreturn generateTerrain();\n})`
									}
								]
							},
							{
								name: 'cubicle',
								type: 0,
								description: `Cubicle is the ${_app_name} public chat room, where users discuss about ${_app_subject_name} and other topics. The files they share are stored here, all in subfolders by user name (15-characters max, you can use parody of real sauer player names (replace some character or make an adaptation)). With exception of logs, only folders are allowed, and must not contain folder path. The root folder must include log files of the conversations identified by the date in the format 'YYYY-MM-DD_HH-MM-SS.log'. For the logs conversation: The conversation must be centered around a random sauer topic. Include this at the end of the content description: "Each user expresses themselves differently and has their own personality, messages are natural with no overused capitalization, the players personality are really different from each other."`,
								child: []
							},
						]
					};

					// initialize with reference directly to tree to start at the root
					this.currentContext = this.tree.child[0].child;
					this.contextStack = [this.tree, this.tree.child[0]];
				}

				createItem(name, type, description) {
					const newItem = type === 0 ? { name, type, description, child: [] } : { name, type, description, content: '' };
					this.currentContext.push(newItem);
				}

				openItemAt(index) {
					if (!this.currentContext[index]) return;
					const targetItem = this.currentContext[index];
					if (targetItem.type === 0) { // it's a folder
						this.contextStack.push(targetItem); // push the folder to the stack
						this.currentContext = targetItem.child; // navigate into the folder
					}
				}

				returnFolder() {
					if (this.contextStack.length > 1) {
						this.contextStack.pop(); // go back one step in the stack
						this.currentContext = this.contextStack[this.contextStack.length - 1].child; // update current context
					}
				}

				downloadCurrentFolder() {
					const zip = new JSZip();
					const fetchPromises = [];
					const addItemsToZip = (context, zipFolder) => {
						context.forEach(item => {
							if (item.type === 0) { // folder
								const newFolder = zipFolder.folder(item.name);
								addItemsToZip(item.child, newFolder);
							} else if (item.type === 1 && item.content instanceof HTMLImageElement) {
								const promise = fetch(item.content.src, { mode: 'cors' })
									.then(response => {
										if (!response.ok) throw new Error('Network response was not ok');
										return response.blob();
									})
									.then(blob => {
										zipFolder.file(item.name, blob);
									})
									.catch(error => console.error('Error fetching image:', error));
								fetchPromises.push(promise);
							} else { // regular file
								zipFolder.file(item.name, item.content);
							}
						});
					};

					addItemsToZip(this.currentContext, zip);

					Promise.all(fetchPromises)
						.then(() => {
							return zip.generateAsync({ type: 'blob' });
						})
						.then((blob) => {
							let folderName = (this.contextStack.length > 1) ? this.contextStack[this.contextStack.length-2].name : this.contextStack[this.contextStack.length-1].name;
							const url = URL.createObjectURL(blob);
							const link = document.createElement('a');
							link.href = url;
							link.download = folderName || `${_app_name.toLowerCase()}_loopfiles.zip`;
							link.click();
							URL.revokeObjectURL(url);
						})
						.catch((error) => {
							console.error('Error downloading the zip file:', error);
						});
				}

				pushFile(path, content, description = '') {
					const pathElements = path.split('/'); // split the path by '/'
					let currentFolder = this.tree; // start from the root

					for (let i = 0; i < pathElements.length; i++) {
						const element = pathElements[i];
						if (i === pathElements.length - 1) { // if it's the last element, it's a file
							currentFolder.child.push({ name: element, type: 1, description: 'File at ' + path + description, content: content });
						} else { // it's a folder
							let foundFolder = currentFolder.child.find(child => child.name === element && child.type === 0);
							if (!foundFolder) { // if folder does not exist, create it
								foundFolder = { name: element, type: 0, description: 'Folder in ' + path, child: [] };
								currentFolder.child.push(foundFolder);
							}
							currentFolder = foundFolder; // move to the next level
						}
					}
				}

				openFolder(path) {
					const pathElements = path.split('/'); // split the path by '/'
					let currentFolder = this.tree; // start from the root
					this.contextStack = [this.tree]; // reset context stack to root

					for (const element of pathElements) {
						const foundFolder = currentFolder.child.find(child => child.name === element && child.type === 0);
						if (foundFolder) {
							this.contextStack.push(foundFolder); // update context stack
							currentFolder = foundFolder; // move to the next level
						} else {
							console.error('Folder not found:', element);
							break; // stop if folder is not found
						}
					}

					if (currentFolder) {
						this.currentContext = currentFolder.child; // Set the current context
					}
				}
			}

			class TextEditor {
				constructor(parent) {
					this.forceLang = false;
					this.parent = parent;
					this.textarea = document.createElement('textarea');
					this.textarea.className = 'texteditor_editor';
					this.textarea.setAttribute('spellcheck', false);

					this.pre = document.createElement('pre');
					this.pre.className = 'texteditor_pre';
					this.pre.setAttribute('aria-hidden', true);

					this.code = document.createElement('div');
					this.code.className = 'texteditor_code';

					this.textarea.addEventListener('input', () => {
						this.refreshHighlight();
					});

					this.textarea.addEventListener('scroll', () => {
						this.refreshScroll();
					});

					this.pre.appendChild(this.code);
					this.parent.appendChild(this.textarea);
					this.parent.appendChild(this.pre);
				}

				refreshScroll() {
					if (!this.code.firstChild) return;
					this.code.firstChild.scrollTop = this.textarea.scrollTop;
					this.code.firstChild.scrollLeft = this.textarea.scrollLeft;
				}

				async refreshHighlight() {
					this.code.textContent = this.textarea.value;
					let detectedLang = this.forceLang || detectLanguage(this.textarea.value);

					let langClass = `shj-lang-${detectedLang}`;
					if (!this.textarea.classList.contains(langClass)) {
						this.textarea.className = this.textarea.className.replace(/\bshj-lang-\S+/g, '');
						this.textarea.classList.add(langClass);
					}

					await highlightElement(this.code, detectedLang, 'multiline', {'hideLineNumbers': true});

					this.refreshScroll();  // ensure scroll sync happens after content update

				}
			}

			class JSOCTA_helper {
				constructor() {
					this.mapvars = {'maptitle': `map created with ${_app_name}`};
					this.entities = [];
					this.geometry = [];
				}

				set_mapvars(object = {}) {
					if (typeof object === 'function') {
						object = object();
					}
					this.mapvars = object || {};
				}

				set_entities(object = []) {
					if (typeof object === 'function') {
						object = object();
					}
					this.entities = object || [];
				}

				set_geometry(object = []) {
					if (typeof object === 'function') {
						object = object();
					}
					this.geometry = object || [];
				}
			}

			const desktop = new DesktopApps('#desktop_apps_list');
			const saueracle_explorer = new TreeExplorer();

			window.onload = () => {
				_alert_gif('SaueracleOS is undergoing reforms to adapt to the new WebSim API, things might be faster, but may not work as well as before, be patient with the tinheads!', false);
				document.title = _app_name;
				let div_start_menu = document.createElement('div');
				div_start_menu.innerHTML = `
					<h2>Welcome to ${_app_name == 'SaueracleOS' ? _app_name : `${_app_name}, a SaueracleOS modification`}</h2><br>
					<p> SaueracleOS was put together by <a href="https://salatielsauer.github.io/" target="_blank" onclick="_fix_link_redirect(this)">@SalatielSauer</a>, who takes no responsibility for any dubious content found here, it's all the robots' fault.<br>If you don't know what this is all about, download <a href="http://sauerbraten.org/" target="_blank" onclick="_fix_link_redirect(this)">sauerbraten.org</a> and join <a href="https://discord.gg/j3kyxtj" target="_blank" onclick="_fix_link_redirect(this)">this discord channel</a>.<br><br>Special thanks to <a href="https://github.com/cfoust" target="_blank" onclick="_fix_link_redirect(this)">@Caleb Foust</a> for providing <a href="https://github.com/cfoust/sour" target="_blank">Sour</a>, the web version of Sauerbraten.<br><br>Special thanks to <a href="https://github.com/AngrySnout" target="_blank" onclick="_fix_link_redirect(this)">@AngrySnout</a> for providing the <a href="https://github.com/AngrySnout SauerTracker" target="_blank" onclick="_fix_link_redirect(this)">SauerTracker</a> API.</p><br>
					<h2>The creativity waypoint</h2><br>
					${_app_name} is a set of tools designed for creating and managing content for ${_app_subject_name_short} using a generative language model. It originally runs on the Websim platform, which provides free access to the Claude AI model through its generative API.
					<br><br>
					<strong>Map Generation</strong><br>
					Using 'Josias the Mapper', you have access to an embedded JSOCTA (a JS class that allows you to convert json to valid .ogz files), the 'Josias' bot receives any text instruction and does the entire process of generating the formula needed to generate the map for download.

				`
				let start_menu = desktop.addWindow(`Welcome to ${_app_name} v${_app_version}`, div_start_menu, _icon_main, 400, 800, 200, 130, true);
				start_menu.body.querySelector('.app_window_header').style.pointerEvents = 'none';
				start_menu.body.style.display = 'none';
				start_menu.body.style.top = 'unset';
				start_menu.body.style.bottom = '0px';
				start_menu.body.style.transform = 'unset';
				start_menu.body.style.resize = 'unset';
				start_menu.open = false
			}

			// System Info
			desktop.addIcon('Computer Info', _icon_info, (e, iconImage) => {
				let api = new APIFetchContextual(_api_endpoint_htmlgenerator)
				let div = desktop._nelement('div');
				let computer_info = desktop.addWindow(`Computer Info - ${_app_name} v${_app_version}`, div, iconImage, 733, 574, 550, 120);

				let default_html_generator_prompt = `follow these instructions exactly: content must be a string: "<div>Benchmark tests</div>", you must generate
					`;
				
				computer_info.loading(true);
				get_computer_info();

				function get_computer_info(attempts = 0) {
					api.post(default_html_generator_prompt, 
						response => response.content,
						data => {
							data = data.replace(/```html\s*|\s*```/g, '');
							data = data.replace(/\"html\s*|\s*\"/g, '');
							console.log('Computer info response:', data);
							//data = JSON.parse(data);

							if (data.length <= 100) {
								if (attempts >= 5) {
									div.innerHTML = `<h2>ðŸ’»ðŸ”¨ Running benchmark tests...</h2><br><h2>Failed, Please restart this application to try again.</h2>`
									return;
								};
								div.innerHTML = `<h2>ðŸ’»ðŸ”¨ Running benchmark tests...</h2>`
								computer_info.loading(true);
								get_computer_info(attempts+=1)
								return;
							}
							//div.innerHTML = data.replace(/^`+|`+$/g, '');
							div.innerHTML = data;
							computer_info.loading(false);
						},
						error => {
							console.error('Failed to process API request', error);
						}
					);
				}
			});

			// Server Browser, Server Preview & Player Profile Generator
			desktop.addIcon('Server Browser', _icon_server, (e, iconImage) => {
				let api = new APIFetchContextual(_api_endpoint_htmlgenerator);
				let api_tracker_servers = new APIFetchContextual(_api_endpoint_gametracker_servers);
				let tracker_servers_active = [];
				let div = desktop._nelement('div');
				div.style.textAlign = 'center';

				// Window: Server Browser
				let window_server_browser = desktop.addWindow('Server Browser - Powered by <img class="app_window_icon" src="https://sauertracker.net/images/squid.png"><a href="https://sauertracker.net/" target="_blank">Sauertracker.net</a>', div, iconImage, 512, 512, 550, 120);
				window_server_browser.loading(true);
				api_tracker_servers.get(
					response => response,
					data => {
						console.log('Sauertracker servers response:', data);
						tracker_servers_active = data.filter(server => server.clients > 0);
						api.post(`Create an HTML-formatted list of cards containing the ${_app_subject_name_short} servers: ${JSON.stringify(tracker_servers_active)} (if it is empty, make up some creative ones). Format the response in HTML (add inline css to the elements, prefer dark-mode style, make sure the elements are clickable, not markdown.) add a footnote funfact about Cube 2 (unrelated to pot roast) or the servers or the activity status. Add emojis. If servers are not empty: add onclick="window.custom_bind_showServerInfo(event, 'ip here', 'port here', 'description with emojis')", no escaping.`,
							response => response.content,
							data => {
								data = data.replace(/```html\s*|\s*```/g, '');
								console.log('HTML response for server browser:', data);
								let newdiv = desktop._nelement('div');
								newdiv.innerHTML = data.replace(/^`+|`+$/g, '');
								div.appendChild(newdiv);
								window_server_browser.loading(false);
							},
							error => {
								_alert_gif(`${error}`)
								tracker_servers_active.forEach(server => {
									let p = document.createElement('p');
									p.style.backgroundColor = '#141414';
									p.style.padding = '10px';
									p.style.borderStyle = 'solid';
									p.style.borderWidth = '1px';
									p.style.boxShadow = '0 0 7px black';
									p.innerHTML += `ðŸ“¡${server.descriptionStyled}`;
									div.appendChild(p);
								})
								window_server_browser.loading(false);
								//div.innerHTML = `Websim API error: <h2>${error}</h2><br><p>Sauertracker response: ${JSON.stringify(tracker_servers_active)}</p>`;
							}
						);
					},
					error => {
						div.innerHTML = `Sauertracker error: <h2>${error}</h2>`;
					}
				);

				// Window: Player Profile Preview
				let div_find_player_container = desktop._nelement('div');

				let input_player_name = desktop._nelement('input');
				input_player_name.type = 'text';
				input_player_name.placeholder = 'Player Name';
				input_player_name.className = '_app_chat_textarea';

				let button_find_player = desktop._nelement('button');
				button_find_player.className = '_app_button';
				button_find_player.textContent = 'Find Player Profile';

				button_find_player.addEventListener('click', (e) => {
					console.log('finding profile')
					let div_profile = desktop._nelement('div');
					let api_tracker_player = new APIFetchContextual(`${_api_endpoint_gametracker_player}/${input_player_name.value}`);
					let window_player_profile = desktop.addWindow(`ðŸ‘¤ ${input_player_name.value}'s not-so-true Profile`, div_profile, iconImage, 600, 312, e.clientX, e.clientY);
					window_player_profile.subIcon = 'ðŸ‘¤';
					window_player_profile.loading(true);

					api_tracker_player.get(
						response => response,
						data => {
							// stringify data
							data = JSON.stringify(data);
							console.log('Player profile response:', data);
							api.post(`Response must be HTML div, no <head>, no <title>. CSS must not affect all elements of the page. Create an standalone HTML-formatted card containing a cool profile with infos about the following Cube 2 Sauerbraten player: ${data} (if it's empty, make up a creative one for ${input_player_name.value}). Add emojis. Put some bar graphs. Do not add avatar images. Format the response in HTML (add inline css to the elements, prefer dark-mode style), make a footnote funfact about the player. The stats must be true, you can like everything else, just don't go overboard with lies.`,
								response => response.content,
								data => {
									data = data.replace(/```html\s*|\s*```/g, '');
									data = data.replace(/\"html\s*|\s*\"/g, '');
									console.log('Player profile response:', data);
									div_profile.innerHTML = data.replace(/^`+|`+$/g, '');
									window_player_profile.loading(false);
								}
							)
						}
					);
				})

				div_find_player_container.appendChild(input_player_name);
				div_find_player_container.appendChild(button_find_player);
				div.appendChild(div_find_player_container);

				// Window: Server Preview
				window.custom_bind_showServerInfo = (e, ip, port, description) => {
					console.log(e.clientX, e.clientY, )
					let api_tracker_server = new APIFetchContextual(`${_api_endpoint_gametracker_server}/${ip}/${port}`);
					let div = desktop._nelement('div');
					let window_server_preview = desktop.addWindow(`${description} - ${ip}:${port}`, div, iconImage, 600, 312, e.clientX, e.clientY);
					window_server_preview.subIcon = 'ðŸ–¥ï¸';
					window_server_preview.loading(true);

					api_tracker_server.get(
						response => response,
						data => {
							api.post(`Response must be HTML div, no <head>, no <title>. CSS must not affect all elements of the page. Create an standalone HTML-formatted card containing info about the following server: ${JSON.stringify(data)} (if it's empty, make up a creative one). Add emojis. List all Players with their stats etc. Format the response in HTML (add inline css to the elements, prefer dark-mode style), make a footnote funfact. set a background cover for the server with the link ${_api_endpoint_gametracker_mapshots}/MAPNAME.jpg`,
								response => response.content,
								data => {
									data = data.replace(/```html\s*|\s*```/g, '');
									console.log('Server preview response:', data);
									div.innerHTML = data.replace(/^`+|`+$/g, '');
									window_server_preview.loading(false);
								}
							)
						},
						error => {
							//div.innerHTML = `Sauertracker Server error: <h2>${error}</h2>`;
							div.innerHTML = 'Failed to request Sauertracker data';
							_alert_gif(error)
							
						}
					);
				}

			})

			function _loopfiles_open(e, iconImage) {
				let api = new APIFetchContextual(_api_endpoint_filegenerator);
				let loopfiles_div = desktop._nelement('div');
				let loopfiles_window = desktop.addWindow('LoopFiles - The File Explorer loophole', loopfiles_div, iconImage, 712, 456, e.clientX, e.clientY);
				//loopfiles_window.loading(true);
				loopfiles_div_icons = document.createElement('div');
				loopfiles_div_icons.style.display = 'flex';
				loopfiles_div_icons.style.flexWrap = 'wrap';
				loopfiles_div_icons.style.maxHeight = '310px';
				loopfiles_div_icons.style.minHeight = '310px';
				loopfiles_div_icons.style.overflow = 'auto';
				
				function addIcon(title, image, onclick = (e)=>{}) {
					let div_icon = document.createElement('div');
					div_icon.className = 'desktop_app';
					div_icon.style.width = '160px';
					div_icon.addEventListener('click', (event) => onclick(event));

					let img_icon = document.createElement('img');
					img_icon.src = image;

					let div_title = document.createElement('div');
					div_title.className = 'desktop_app_title';
					div_title.textContent = title;

					div_icon.appendChild(img_icon);
					div_icon.appendChild(div_title);

					loopfiles_div_icons.appendChild(div_icon);
					return img_icon;
				}

				let div_create_item_container = desktop._nelement('div');

				let input_item_name = desktop._nelement('input');
				input_item_name.type = 'text';
				input_item_name.placeholder = 'Folder/File name';
				input_item_name.className = '_app_chat_textarea';
				input_item_name.style.verticalAlign = 'middle';
				input_item_name.addEventListener('input', (e) => {
					if (e.target.value.trim().length == 0) {
						button_create_item.setAttribute('disabled', '')
					} else {
						button_create_item.removeAttribute('disabled')
					}
				})

				let button_create_item = desktop._nelement('button');
				button_create_item.className = '_app_button';
				button_create_item.textContent = 'âž•Create';
				button_create_item.style.fontSize = '11px';
				button_create_item.style.padding = '5px';
				button_create_item.setAttribute('disabled', '')
				button_create_item.addEventListener('click', (e) => {
					if (input_item_name.value.trim().length == 0) return;
					saueracle_explorer.createItem(input_item_name.value, +input_item_name.value.includes('.'), `The folder contents must match its name: ${input_item_name.value}`);
					drawCurrentFolder();
				})

				div_create_item_container.appendChild(input_item_name);
				div_create_item_container.appendChild(button_create_item);

				let button_download_folder = desktop._nelement('button');
				button_download_folder.className = '_app_button';
				button_download_folder.textContent = 'ðŸ“¦ ZIP Folder';
				button_download_folder.style.fontSize = '11px';
				button_download_folder.style.padding = '5px';
				button_download_folder.style.float = 'right';
				button_download_folder.addEventListener('click', (e) => {
					saueracle_explorer.downloadCurrentFolder();
				})

				function drawCurrentFolder() {
					const isImageFile = filename => /\.(jpg|jpeg|png|gif|bmp|webp)$/i.test(filename);
					let currentPath = saueracle_explorer.contextStack.map((item, index) => `${index != 0 ? '/' : ''}${item.name}`).join('');
					let hr = document.createElement('hr');
					hr.style.borderStyle = 'solid';
					hr.style.borderColor = '#171717';
					let p = document.createElement('p');
					loopfiles_div.innerHTML = '';
					p.style.backgroundColor = '#171717';
					p.style.minWidth = '50%';
					p.style.fontSize = 'small';
					p.style.padding = '2px';
					p.style.verticalAlign = 'middle';
					p.innerHTML = `ðŸ“‚<i>${currentPath}</i>`;
					loopfiles_div.appendChild(button_download_folder);
					loopfiles_div.appendChild(p);
					loopfiles_div.appendChild(div_create_item_container);
					
					loopfiles_div.appendChild(hr);
					loopfiles_div_icons.innerHTML = '';
					loopfiles_div.appendChild(loopfiles_div_icons);
					if (saueracle_explorer.contextStack.length > 1) {
						addIcon(saueracle_explorer.contextStack[saueracle_explorer.contextStack.length-2].name, _icon_back, (e) => {
							saueracle_explorer.returnFolder();
							console.log('returning to previous folder');
							drawCurrentFolder();
							return;
						})
					}
								
					loopfiles_window.onrefresh = () => { // re-generate current folder
						const currentNode = saueracle_explorer.contextStack[saueracle_explorer.contextStack.length - 1];
						loopfiles_window.loading(true);
						api.post(`return an array of different and plausible ${_app_subject_name_short.toLowerCase()} or system related files and folders with the format [{name, type 0 for folder 1 for file, must include a 'description' property with a context, child: [] (if folder), content: [] (if file)}], keep child and content empty. file names must contain their extension. File names must not contain folder path. Do not repeat folders or file names, be creative, all the content must make sense with the parent folder. Folders come first. The current parent path is '${currentPath}/${currentNode.name}' Extra info about the parent folder: ${currentNode.description}. Make sure the folder content is consistent with its path and parent name as much as possible. The description for images must describe the content of the image and the width:xxx height:xxx attributes.`,
							response => response.content,
							data => {
								data = JSON.parse(data);
								currentNode.child = data; // directly modify the children of the current node
								saueracle_explorer.currentContext = currentNode.child; // update the current context to the new children
								console.log('regenerating folder', data)
								drawCurrentFolder();
								loopfiles_window.loading(false);
							}
						)
					}

					saueracle_explorer.currentContext.forEach((item, index) => {
						let icon = addIcon(item.name, (item.name.includes('.jsocta')) ? _icon_jsocta : (item.type == -1) ? _icon_back : (item.type == 0) ? (item.child.length == 0) ? _icon_folder_empty : _icon_folder : (item.content.length == 0) ? _icon_file_empty : _icon_file, (e) => {
							if (item.type == 0) { // folder
								saueracle_explorer.openItemAt(index);


								if (item.child.length != 0) {
									console.log('loading existing folder:', item.child);
									drawCurrentFolder();
									loopfiles_window.loading(false);
									return;
								}

								//loopfiles_window.loading(true);
								console.log('generating folder:', item);
								loopfiles_window.loading(true);
								api.post(`return an array of plausible ${_app_subject_name_short.toLowerCase()} or system related files and folders with the format [{name, type 0 for folder 1 for file, must include 'description' containing a context}], file names must contain their extension. File names must not contain folder path. Do not repeat folders or file names, be creative, all the content must make sense with the parent folder. Folders come first. The current path is '${currentPath}/${item.name}' Extra info about the folder you are creating: ${item.description}. Make sure the folder content is consistent with its path and name. The description for images must describe the content of the image and the width:xxx height:xxx attributes.`,
									response => response.content,
									data => {
										console.log('got response', data)
										data = JSON.parse(data);
										data.forEach(item => {
											saueracle_explorer.createItem(item.name, item.type, item.description);
										})
										drawCurrentFolder();
										loopfiles_window.loading(false);
									},
									error => {
										_alert_gif(error);
										loopfiles_window.loading(false);
									}
								)
							}

							if (item.type == 1) { // image file
								const isImageFile = filename => /\.(jpg|jpeg|png|gif|bmp|webp)$/i.test(filename);
								let notepad_div = document.createElement('div');
								let notepad_window = desktop.addWindow(`ðŸ“„${_truncate_string(currentPath, 60)}/${_truncate_string(item.name, 30)} ${item.name.includes(".jsocta") ? ' | <a target="blank" href="https://salatielsauer.github.io/OGZ-Editor/">Check out OGZ-Editor!</a>' : ""}`, notepad_div, _icon_file, 1024, 712, e.clientX, e.clientY);
								notepad_window.loading(true);

								if (isImageFile(item.name)) {
									console.log('opening image file', item.name);
									notepad_window.subIcon = 'ðŸ–¼ï¸';
									getImageFile((img) => {
										notepad_div.innerHTML = '';
										notepad_div.appendChild(img);

										// Download button
										const button_download_img = document.createElement('button');
										button_download_img.className = '_app_button';
										button_download_img.textContent = 'ðŸ’¾Save Image';
										notepad_div.appendChild(button_download_img);

										button_download_img.addEventListener('click', () => {
											button_download_img.disabled = true;
											notepad_window.loading(true);

											// Use proxy only for download
											const proxyUrl = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(img.src);
											fetch(proxyUrl)
												.then(response => {
													if (!response.ok) throw new Error("Proxy fetch failed");
													return response.blob();
												})
												.then(blob => {
													const url = URL.createObjectURL(blob);
													const link = document.createElement('a');
													link.href = url;
													link.download = item.name;
													link.click();
													setTimeout(() => URL.revokeObjectURL(url), 1000);
												})
												.catch(err => {
													alert('Failed to download image: ' + err);
												})
												.finally(() => {
													button_download_img.disabled = false;
													notepad_window.loading(false);
												});
										});

										notepad_window.loading(false);
									});


									return;
								}

								// any other file is treated as text (except images).

								notepad_window.subIcon = 'ðŸ“„';

								let textEditor = new TextEditor(notepad_div);
								textEditor.forceLang = false;

								let div_notepad_menu = document.createElement('div');
								div_notepad_menu.className = '_detached';

								let button_save_text = document.createElement('button');

								function update_save_button() {
									if (textEditor.textarea.value != item.content) {
										button_save_text.textContent = 'ðŸ’¾Save File';
										textEditor.code.style.outlineColor = '#1d64ad';
										textEditor.code.style.outlineStyle = 'dashed';
									} else {
										button_save_text.textContent = 'ðŸ“¥Download File'
										textEditor.code.style.outlineStyle = 'none';
									}
								}

								button_save_text.className = '_app_button _app_button_small';
								button_save_text.addEventListener('click', () => {
									if (item.content == textEditor.textarea.value) {
										_download_file(item.name, item.content, 'plain/text');
										return;
									}
									item.content = textEditor.textarea.value;
									update_save_button();
								})
								
								update_save_button();
								textEditor.textarea.addEventListener('click', () => { update_save_button(); });
								textEditor.textarea.addEventListener('input', ()=> { update_save_button(); });

								div_notepad_menu.appendChild(button_save_text);

								// JSOCTA javascript files, displays button for running them.
								if (item.name.includes('.jsocta')) { 
									textEditor.forceLang = 'js';
									let button_run_jsocta = document.createElement('button');
									button_run_jsocta.className = '_app_button _app_button_small _app_button_detached';
									button_run_jsocta.textContent = 'ðŸ“¦Compile .OGZ';
									button_run_jsocta.addEventListener('click', () => {
										let jsocta_map = new JSOCTA_helper();

										item.content = textEditor.textarea.value;
										
										let jsocta_user_script = new Function('mapvars', 'entities', 'geometry', _simple_trim(textEditor.textarea.value));
										jsocta_user_script(jsocta_map.set_mapvars.bind(jsocta_map), jsocta_map.set_entities.bind(jsocta_map), jsocta_map.set_geometry.bind(jsocta_map));

										_jsocta_jsonToOGZ(
											{
												"mapvars": jsocta_map.mapvars,
												"entities": jsocta_map.entities,
												"geometry": jsocta_map.geometry
											},
											log => {
												console.log('loopfiles jsocta implementation:', log)
											}, file => {
												_download_file(item.name.replace('.jsocta', '.ogz'), file.GZIP);
											}, error => {
												alert(error)
											}
										)
									})
									div_notepad_menu.appendChild(button_run_jsocta)
								}

								if (item.name.includes('.cfg')) {
									//item.description += '. it must follow the cubescript syntax of `command "argument" [block]` like sensitivity 5; or loop i 10 [echo $i], commands can go without block arguments.';
									// Only if needed, and if it is an interface, use functional gui* commands too: newgui "myinterface" [guititle "hi"; guibutton "close" [cleargui]; guibar; guilist [guitext "same"; guititle "line"]; guifield yourname 15 [echo (concat "your 15-characters name is" $yourname); name $yourname]], showgui "myinterface"
									let api_guiscript = new APIFetchContextual(_api_endpoint_htmlgenerator)
									//textEditor.forceLang = 'js';
									let button_run_guiscript = document.createElement('button');
									button_run_guiscript.className = '_app_button _app_button_small _app_button_detached';
									button_run_guiscript.textContent = 'ðŸ‘ï¸â€ðŸ—¨ï¸Preview GUI';
									button_run_guiscript.addEventListener('click', (e) => {
										notepad_window.loading(true);
										api_guiscript.post(`Return a GUI that follows the user's script input: "${textEditor.textarea.value}".
										Try your best to make functional features with javascript, add inline css to the elements, prefer dark-mode style. Include emojis. Make the width/height size be enough to fit the content. Do not include "explanations", all the content must be inside the html. Do not make "placeholders".`,
											response => response.content,
											response => {
												response = response.replace(/```html\s*|\s*```/g, '');
												console.log('guiscript response:', response);
												notepad_window.loading(false);
												if (!response) return;

												// create a container div
												let guiscript_div = document.createElement('div');
												guiscript_div.innerHTML = `<p>this ${_app_name.toLowerCase()} feature is unfinished and you shouldn't be seeing it</p><br>`;

												// create the iframe element
												let iframe = document.createElement('iframe');
												iframe.style.width = '100%';
												iframe.style.height = '400px';

												// use srcdoc to set the content of the iframe
												iframe.srcdoc = response;

												// append the iframe to the container div
												guiscript_div.appendChild(iframe);
												let guiscript_window = desktop.addWindow(`ðŸ“„${item.name} (ðŸ‘ï¸â€ðŸ—¨ï¸)`, guiscript_div, _icon_file, 512, 512, e.clientX, e.clientY);
												guiscript_window.subIcon = 'ðŸ‘ï¸â€ðŸ—¨ï¸';
											},
											error => {
												_alert_gif(error);
												notepad_window.loading(false);
											}
										)
									})
									div_notepad_menu.appendChild(button_run_guiscript)
								}

								notepad_div.appendChild(div_notepad_menu);

								if (item.content.length != 0) {
									textEditor.textarea.value = item.content;
									notepad_window.loading(false);
									textEditor.refreshHighlight();
									return;
								}

								function processChunks(data) {
									if (!Array.isArray(data)) {
										data = [data];
									}

									let offset = 0;
									console.log('processing chunks', data);
									data.forEach(chunk => {
										const startIdx = textEditor.textarea.value.indexOf(chunk.start, offset);
										const endIdx = textEditor.textarea.value.indexOf(chunk.end, startIdx + chunk.start.length) + chunk.end.length;

										if (startIdx === -1 || endIdx === -1) return;

										textEditor.textarea.value = textEditor.textarea.value.substring(0, startIdx) +
																	chunk.content +
																	textEditor.textarea.value.substring(endIdx);

										offset = startIdx + chunk.content.length;
									});

									item.content = textEditor.textarea.value;
								}

								function get_text_content() {
									notepad_window.loading(true);
									let text_prompt;
									if (textEditor.textarea.value.length != 0) {
										text_prompt = `return a single array containing a sequence of 'chunks' of plain text of a plausible content in the format [{start, end, content: '...'}], the start and end are keywords that will be replaced (and everything in between), they represents the start and end of the area that you want to continue, fix, or adapt in the text: '${textEditor.textarea.value}', stick to smart changes, no need to replace the entire text. Extra info about the file you are fixing: Path: '${currentPath}/${item.name}', Description: ${item.description}`;
									} else {
										text_prompt = `return a single object containing a plain text of a plausible content in the format {content: '...'} for the file '${currentPath}/${item.name}'. Extra info about the file you are creating: ${item.description}. Be creative.`;
									}
									api.post(text_prompt,
										response => {
											console.log('first response:', response);
											return response.content;
										},
										data => {
											console.log('last response', data);
											data = JSON.parse(data);
											if (textEditor.textarea.value.length !=0) {
												processChunks(data);
											} else {
												textEditor.textarea.value = data.content;
												item.content = data.content;
											}
											notepad_window.loading(false);
											textEditor.refreshHighlight();
											drawCurrentFolder();
										},
										error => {
											_alert_gif(error);
											notepad_window.loading(false);
										}
									)
								}
								get_text_content();
								notepad_window.onrefresh = ()=> get_text_content();
							}
						});

						async function generateAndSetImageIcon(item, icon, currentPath) {
							try {
								// Use currentPath and item.name as the prompt
								function extractDimension(str, key) {
								// Match 'width:512' or 'height:512' (case-insensitive)
								const regex = new RegExp(`${key}\\s*:\\s*(\\d+)`, 'i');
								const match = str.match(regex);
								return match ? parseInt(match[1], 10) : null;
								}

								function clampOrRandom(val, min = 100, max = 1024) {
								if (!val || val < min || val > max) {
									// Return a random plausible value in range
									return Math.floor(Math.random() * (max - min + 1)) + min;
								}
								return val;
								}

								const widthRaw = extractDimension(item.description, "width");
								const heightRaw = extractDimension(item.description, "height");

								const width = clampOrRandom(widthRaw);
								const height = clampOrRandom(heightRaw);

								const result = await websim.imageGen({
								prompt: `generate the image as if it were located at "${encodeURIComponent(`${currentPath}/${item.name}`)}", and the image description is: "${item.description}". it must match the description and file path as much as possible.`,
								width,
								height,
								seed: Math.floor(Math.random() * 1000000),
								});


								icon.src = result.url;
								icon.alt = `${currentPath}/${item.name} (${item.description})`;
								item.content = { src: result.url };

								icon.onload = () => {
									console.log('Custom icon loaded', icon.src);
								};
							} catch (err) {
								icon.src = _icon_file; // fallback icon
								console.error("Image generation failed", err);
							}
						}

						// generate image
						if (isImageFile(item.name)) {
							if (!item.content) {
								generateAndSetImageIcon(item, icon, currentPath);
							}

							icon.src = item.content.src;
							//icon.alt = `${currentPath}/${item.name} (${item.description})`;
						}

						function getImageFile(callback = ()=>{}) {
							let img = document.createElement('img');
							img.src = item.content.src;
							img.alt = `${currentPath}/${item.name} (${item.description})`;
							//img.width = Math.floor(Math.random() * (512 - 16 + 1)) + 16;
							//img.height = Math.floor(Math.random() * (512 - 16 + 1)) + 16;
							img.style.width = '80%';
							//img.style.height = '80%';
							img.style.left = '10%';
							img.style.top = '10%';
							img.style.boxShadow = '3px 5px 13px #0000006e';
							img.style.filter = 'saturate(1.2)';
							img.style.position = 'absolute';
							callback(img);
						}
						item['element'] = icon;
					})
					
				}
				drawCurrentFolder()
			};
			desktop.addIcon('LoopFiles Explorer', _icon_folder, (e, iconImage) => _loopfiles_open(e, iconImage));

			desktop.addIcon('Cubicle', _icon_chat, (e, iconImage) => {
				let chat = new ChatWindow('cubicle');
				let cubicle = new APIFetchContextual(_api_endpoint_chatgenerator);
				let cubicle_window = desktop.addWindow('Cubicle - Sauerworld', chat.div_chat, iconImage, 712, 456, e.clientX, e.clientY);

				chat_flow.ontyping((status, user) => {
					if (status.length > 0) {
						chat.showStatus(`ðŸ’¬${status}`);
					} else {
						chat.showStatus('');
					}
				})

				chat_flow.onsilence(() => {
					cubicle.post(`The chat went into a silence for the past minute, From context: '${chat_flow.sentMessages.map(m => `"${m.name}: ${m.message}"`).join()}', Return related an array of messages object with format [{name: name, message: message}], where the name is a player name with maximum of 15 characters, continue the ongoing conversation, feel free to join someone new etc. Make messages natural with no overused capitalization. 'Unnamed' is the real user, do not use it in the response. You can reply to unnamed's message tho.`,
						response => response.content,
						data => {
							data = JSON.parse(data);
							console.log('cubicle silence response:', data);
							data.forEach((user, index) => {
								chat_flow.addToQueue({
									name: user.name,
									message: user.message,
									onSend: (msg) => {
										chat.pushMessage(msg.name, msg.message);
									}
								});
							})

							cubicle_window.loading(false);
						}
					);
				});


				if (chat_flow.readyQueue.length == 0) {
					chat.showStatus('<span class="extra_spin">â†»</span> Loading previous messages...');
					cubicle_window.loading(true);
					cubicle.post(`Return an array of ongoing ${_app_subject_name} - related messages with the format [{name, message}], where the name is a player name with maximum of 15 characters. You can use parody of real sauer player names (replace some character or make an adaptation). The conversation must be centered around a random sauer topic. Each user expresses themselves differently and has their own personality. Make messages natural with no overused capitalization. Make the players personality really different.`,
						response => response.content,
						data => {
							data = JSON.parse(data);

							data.forEach((user, index) => {
								chat_flow.addToQueue({
									name: user.name,
									message: user.message,
									onSend: (msg) => {
										chat.pushMessage(msg.name, msg.message);
									}
								});
							})
							// insta send half of the messages
							chat_flow.instaSend(Math.floor(data.length / 3));

							cubicle_window.loading(false);
						}
					);

				} else {
					chat_flow.sentMessages.forEach(user => {
						chat.pushMessage(user.name == 'unnamed' ? -1 : user.name, user.message);
					})
					cubicle.post(`From context: '${chat_flow.sentMessages.map(m => `"${m.name}: ${m.message}"`).join()}', Return a single ${_app_subject_name.toLowerCase()} - related message object with format {name: name, message: message}, where the name is a player name with maximum of 15 characters, continue the ongoing conversation, feel free to join someone new etc. Make messages natural with no overused capitalization.`,
						response => response.content,
						data => {
							chat.showStatus(`ðŸ’¬${chat_flow.typingStatus}`);
							data.forEach((user, index) => {
								chat_flow.addToQueue({
									name: user.name,
									message: user.message,
									onSend: (msg) => {
										chat.pushMessage(msg.name, msg.message);
									}
								});
							});
						}
					)
				}

				function sendInput() {
					if (chat.textarea_chat.value.trim().length == 0) return;
					chat.pushMessage(-1, chat.textarea_chat.value);
					chat_flow.sentMessages.push({
						name: 'unnamed',
						message: chat.textarea_chat.value
					});
					const context = chat_flow.getContext({ pastCount: 5, futureCount: 5 }); // for example, 5 previous + current anchor

					// collect past + anchor messages for display
					const contextMessages = [
					...context.past,
					context.anchor,
					...context.future
					].filter(Boolean); // in case anchor is null
					console.log('context messages:', contextMessages);
					cubicle.post(`From context: '${contextMessages.map(m => `"${m.user || m.name}: ${m.message}"`).join(", ")}', Return one o more ${_app_subject_name.toLowerCase()} - related message array with format [{name: name, message: message}], always follow the conversation flow set by the user ('unnamed'), the most recent message is the one sent by 'unnamed', the others after it are messages coming togheter with yours. if unnamed directs a message to someone, make sure that person replies, others may talk to each other etc. feel free to join someone new etc. Your generated names must not include 'unnamed' because it is the real user. Never Repeat Unnamed's Messages. 'shoot better' and the fact that sauer takes too long to get a new release are common jokes. Each user expresses themselves differently and has their own personality. Do not repeat unnamed's message. Do not treat user as god or anything, he is just a player. Make messages natural with no overused capitalization. You can return like 3-5 messages at once, but do not return more than 10 messages in a single response. atleast half the responses must not be directed to unnamed. Please never generate response using unnamed's name, it is the real user. You can reply to unnamed's message tho. Stick with each player's personality.`,
						response => response.content,
						data => {
							data = JSON.parse(data);
							console.log('cubicle response:', data);
							data.forEach((user, index) => {
								chat_flow.addToQueue({
									name: user.name,
									message: user.message,
									onSend: (msg) => {
										chat.pushMessage(msg.name, msg.message);
									}
								});
							})
						}
					)
					chat.textarea_chat.value = '';
				}
				chat.button_send.addEventListener('click', () => {
					sendInput();
				});
				chat.textarea_chat.addEventListener('keydown', (e) => {
					if (e.key === 'Enter' && !e.shiftKey) {
					    e.preventDefault(); 
					    sendInput();
					}
				});

			})
			// desktop.addIcon('GuiScript', 'https://i.imgur.com/IBCW4P3.jpeg', (e) => {console.log('show guiscript', e)})
			desktop.addIcon(`Josias The Mapper`, _icon_josias, (e, iconImage) => {
				let chat = new ChatWindow('josias');
				let josias = new APIFetch(_api_endpoint_functiongenerator);
				window.josias_js_history = [];
				window.josias_replying = false;

				//let josias_base_prompt = `_addCube returns an array as the cube. Each cube measures 4x4, within a 1024 cube octree. No overlapping cubes. Texture indexes are from 0 to 1704. Include the function and ';return genGeometry();' in one scope. Center structure at 512,512,512. Z is up. Minifiy the javascript. Be Smart & Creative. Textures: 1 default, 2 grass, 767 grass2, 6 wall, 831 yellow, 832 red, 833 blue, 834 green, 777 black. If asked, use _addGround(texture) to add a ground to the bottom part of the map. Finish your response with the return genGeometry(). Make sure you don't get max call stack errors. Always return a flat array of objects.`

				let josias_base_prompt = `Your response must be a object containing a javascript Function body in the format {body: '...'}. Do not include backticks. Use math to craft a JS formula that concats _addCube(x, y, z, texture) to build a 3D map for ${_app_subject_name_short}. Your function body must return the formula result. _addCube returns an array that defines the cube properties. Each cube measures 4x4, within a 1024 cube octree world. No overlapping cubes. Texture indexes are from 0 to 1704. Center structure at 512,512,512. Z is up. Be Smart & Creative, prefer structures with a greater number (less than 500000) of cubes and well detailed. Some textures: 1 default, 2 grass, 767 grass2, 6 wall, 831 yellow, 832 red, 833 blue, 834 green, 777 black. Do not return any plain text. You must only return the formula result. IF solicited, use the existing global helper function _addText(text, x, y, z) to generate a 3D text at the given position or the global helper _addGround(texture) to add 4 512x512 cubes at the bottom part of the map. Do not add texts nor ground if not requested by the user. Your function must always return an array. Do not redefine helper functions (_addCube, _addText, _addGround) they already exists in the global scope.`;

				let josias_base_prompt_simple = `Your response must be a object containing a javascript Function body in the format {body: '...'}. Do not include backticks. Use math to craft a JS formula that concats _addCube(x, y, z, texture) to build a 3D map for ${_app_subject_name_short}. Your function body must return the formula result. _addCube returns an array that defines the cube properties. Each cube measures 4x4, within a 1024 cube octree world. No overlapping cubes. Texture indexes are from 0 to 1704. Center structure at 512,512,512. Z is up. Do not redefine helper functions (_addCube, _addText, _addGround) they already exists in the global scope.`;

				let josias_base_prompt_tryhard = `Your response must be a object containing a javascript Function body in the format {body: '...'}. Do not include backticks. Create a JavaScript math formula that constructs a 3D map for ${_app_subject_name_short} using the global function _addCube(x, y, z, texture). Each cube is 4x4 within a 1024 cube octree, centered at (512, 512, 512) with 'z' as the vertical axis. The function must return the array of cubes created, ensuring no overlapping cubes and using texture indexes from 0 to 1704. Consider these texture examples: 1 (default), 2 (grass), 767 (grass2), 6 (wall), 831 (yellow), 832 (red), 833 (blue), 834 (green), and 777 (black). Minimize your JavaScript code for efficiency. Optionally, employ the global _addText(text, x, y, z) for 3D text or the global _addGround(texture) for ground textures, but only if specified. The final result should be visually appealing and functional. Do not redefine helper functions (_addCube, _addText, _addGround) they already exists in the global scope.`

				let josias_window = desktop.addWindow(`Josias The Mapper <button class='_app_button _app_button_small' onclick='window._josias_openWithLoopfiles("JSOCTA", event)'>ðŸ“ Open LoopFiles</button>`, chat.div_chat, iconImage, 712, 456, e.clientX, e.clientY);
				let josias_response_attempts = 0;
				function formatDate() {
					return new Date().toISOString().replace(/-|:|T|\.\d+Z/g, '');
				}

				josias.onfirstresponse = (r => r.content)
				josias.onlastresponse = (r => {
					chat.showStatus(false)
					r = JSON.parse(r);
					function josias_failed(error) {
						console.log('josias receivend an error', error);
						josias_fixit(`âŒðŸ˜ž I was unable to make the map file (${error}), let's try again.`);
					}
				
					function josias_done() {
						josias_window.loading(false);
						chat.showStatus(false);

						chat.pushMessage('Josias', `âœ…ðŸ¤“ I finished our map! <button class='_app_button' onclick='_josias_download_ogz(${_jsocta_gzip_history.length-1})'>ðŸ’¾Get OGZ</button> <button class='_app_button _app_button_small' onclick='josias_reply(${window.josias_js_history.length})'>â†©ï¸</button>`);

						window.josias_reply = (id) => {
							const entry = window.josias_js_history[id];
							chat.showStatus(`âž¡ï¸<i>${_pretty_trim(entry.source.textContent, 50)}</i> (${entry.resultLength} cubes), and:`, true);
							window.josias_replying = entry;
							chat.textarea_chat.focus();
						}

						window.josias_js_history.push({
							'source': chat.lastMessageBy(-1),
							'javascript': r.body,
							'resultLength': generated_javascript.length
						})
					}

					//console.log(r)
					let generated_javascript = new Function(_simple_trim(r.body))();
					console.log('josias reply', r);
					console.log('generated js result:', generated_javascript);

					if (typeof generated_javascript !== 'undefined' && typeof generated_javascript.length !== 'undefined') {
						if (generated_javascript.length == 0) return;
						chat.pushMessage('Josias', `${(generated_javascript.length >= 100) ? `ðŸ§ I painstakingly tallied ${generated_javascript.length} cubes one-by-one, I'll make the map now ðŸ™ƒ` : `You won't believe me if I tell you this only cost ${generated_javascript.length} cubes ðŸ™ˆ`}`)

						let tmp_map = new JSOCTA_helper();
						tmp_map.mapvars = {
							"skybox": "penguins/yonder",
							"maptitle": `6Map generated by bot 8Josias 6from 8${_app_name} 6(5websim.ai/@SalatielSauer6) using 8${generated_javascript.length || 0} 6cubes. \n>>8Prompt: 7${window.josias_replying ? `"${window.josias_replying.source.textContent}" 6+ 7` : ''} "${chat.lastMessageBy(-1).textContent}"`
						}
						tmp_map.geometry = generated_javascript;

						saueracle_explorer.pushFile(`JSOCTA/josias-script_${formatDate()}.jsocta`, `/*request: '${chat.lastMessageBy(-1).textContent}'*/\nmapvars(${JSON.stringify(tmp_map.mapvars)})\ngeometry(()=>{\n${r.body}\n})`);

						// todo: fix window.josias_replying to display the last prompt and the current prompt in the maptitle
						_jsocta_jsonToOGZ({
							"mapvars": tmp_map.mapvars,
							"entities": tmp_map.entities,
							"geometry": tmp_map.geometry
							}, log => {
								chat.showStatus(`<span class="extra_spin">â†»</span> ${log}`)
							}, done => {
								josias_done();
							}, error => {
								josias_failed(error)
							}
						);
						josias_response_attempts = 0;
						return;
					}

					josias_fixit(`âŒðŸ˜ž I failed, I was unable to calculate a reasonably high-quality map.`, _simple_trim(r));
				})

				josias.onerror = (r => {
					console.log('josias-onerror', r.message);
					if (r.message.includes('Per-minute')) {
						chat.pushMessage('Josias', `I tried, but it seems you've hit the fun barrier imposed by WebSim ðŸ¤ª<br><br>Meanwhile, you can play with some .jsocta files in <button class='_app_button _app_button_small' onclick='window._josias_openWithLoopfiles("JSOCTA", event)'>ðŸ“LoopFiles</button>`)
						chat.showStatus("ðŸ•’try again later");
						josias_window.loading(false);
						return;
					};

					let button_josias_fixit = document.createElement('button');
					button_josias_fixit.className = '_app_button';
					if (r.message.includes('Generative API is not allowed')) {
						button_josias_fixit.textContent = `âŒðŸ˜ you... left me alone, I can only work while you watch me. Try Again! ðŸ¤–`;
					} else {
						button_josias_fixit.textContent = `âŒðŸ˜ž Something went wrong (${r}), Try Again?`;
					}
					button_josias_fixit.addEventListener('click', () => josias_fixit('âŒðŸ¤” yeah, still no luck, try later maybe?'));
					chat.showStatus(false);
					josias_fixit(button_josias_fixit)
				})

				function josias_fixit(fail, solution = '') {
					console.log('josias is trying to fix', solution.length, josias_response_attempts)
					josias_window.loading(true);
					chat.showStatus('<span class="extra_flip">âŒ›</span> ðŸ¤” Josias is trying to fix its solution..')
					if (josias_response_attempts >= 10) {
						josias_window.loading(false);
						chat.pushMessage('Josias', fail)
						josias_response_attempts = 0;
						chat.showStatus(false);
						return;
					}

					chat.pushMessage('Josias', `${_random_array([`ðŸ“ Drawing a geometrically precise map!1`, `ðŸ¤“ Assessing the situation...`, `ðŸ§  Engaging my superior intellect...`, `ðŸ›¸ Deploying alien technology...`, `ðŸ•µï¸â€â™‚ï¸ Borrowing brilliance from community archives...`])} (${josias_response_attempts}/10)`)
					josias.post(`${(josias_response_attempts < 5) ? josias_base_prompt : josias_base_prompt_simple}. User request: ${chat.lastMessageBy(-1).textContent}. Your broken solution: ${solution}. Your last attempt didn't work, fix the function to make sure it won't return undefined values.`)
					josias_response_attempts += 1;
				}

				function sendInput() {
					if (chat.textarea_chat.value.trim().length == 0) return;
					let lastInputParent = chat.pushMessage(-1, chat.textarea_chat.value);

					if (window.josias_replying) {
						let replyIndicator = document.createElement('span');
						replyIndicator.style.fontSize = '8px';
						replyIndicator.style.color = 'grey';
						replyIndicator.textContent = `âž¡ï¸${_pretty_trim(josias_replying.source.textContent, 25)}`;
						replyIndicator.innerHTML += '<br>';
						console.log('last input parent', lastInputParent)
						lastInputParent.insertBefore(replyIndicator, lastInputParent.firstChild);

						console.log('last input parent', lastInputParent)
						console.log(`User input: ${window.josias_replying.source.textContent} + ${chat.textarea_chat.value}`);
						josias.post(`'${window.josias_replying.javascript}' adapt, modify or expand this formula, and ${chat.textarea_chat.value}`);
						window.josias_replying = false;
						chat.showStatus('<span class="extra_spin">â†»</span> Josias is adapting previous map..');
					} else {
						console.log('User input:', chat.textarea_chat.value);
						josias.post(`User request: ${chat.textarea_chat.value}. ${josias_base_prompt}`);
						chat.showStatus('<span class="extra_spin">ðŸ§©</span> Josias is mathventuring a new map..');
					}
					chat.textarea_chat.value = ''; // Clear the textarea after sending the message
					josias_window.loading(true);
					
				}

				chat.button_send.addEventListener('click', (e) => {
					sendInput();
				});

				chat.textarea_chat.addEventListener('keydown', (e) => {
					if (e.key === 'Enter' && !e.shiftKey) {
						e.preventDefault(); // Prevent the default action to avoid a new line
						sendInput();
					}
				});

				chat.pushMessage('Josias', 'ðŸ¤– beep bop, what are your orders?')
	
			})
			// desktop.addIcon('Play Sauerbraten', 'https://i.imgur.com/QR97Xra.png', (e) => {console.log("show sour", e)})
			// desktop.addIcon('Guistore App Manager', 'https://i.imgur.com/C5Smnox.jpeg', (e) => {console.log("show guistore", e)})

			desktop.drawIcons();

			interact('.app_window_header').draggable({
				listeners: {
					start (event) { },
					move (event) {
						let parent = event.target.parentNode;
						if (parent.getAttribute('force') == 'true') return;

						let x = (parseInt(parent.getAttribute('pos_x')) || 0) + event.dx;
						let y = (parseInt(parent.getAttribute('pos_y')) || 0) + event.dy;

						// calculate boundaries allowing half of the element to go out of the viewport except for the top
						let minX = -parent.offsetWidth / 2;
						let maxX = window.innerWidth - parent.offsetWidth / 2;
						let minY = 0;  // no negative value for y as we don't allow top half to go out
						let maxY = window.innerHeight - parent.offsetHeight / 2;

						// apply boundaries
						x = Math.max(minX, Math.min(maxX, x));
						y = Math.max(minY, Math.min(maxY, y));

						x = Math.round(x);
						y = Math.round(y);
						parent.setAttribute('pos_x', x);
						parent.setAttribute('pos_y', y);

						event.target.parentNode.style.transform = `translate(${x}px, ${y}px)`;
					},
				}
			});

			function _simple_trim(inputString) {
				// targets quotation marks at the start and end of the string
				return inputString.replace(/^['"`]+|['"`]+$/g, "");
			}

			function _pretty_trim(text, maxLength) {
				if (text.length <= maxLength) {
					return text;
				}

				// find the last space within the allowed length
				const trimmedText = text.slice(0, maxLength + 1);
				const lastSpaceIndex = trimmedText.lastIndexOf(' ');

				// if there's a space, trim to the last word; otherwise, just trim normally
				if (lastSpaceIndex > 0) {
					return trimmedText.slice(0, lastSpaceIndex) + '...';
				}

				return trimmedText.slice(0, maxLength) + '...';
			}

			function _addGround(af) {
				return [{x: 0, y: 0, z: 0, g: 9, af}, {x: 512, y: 0, z: 0, g: 9, af}, {x: 512, y: 512, z: 0, g: 9, af}, {x: 0, y: 512, z: 0, g: 9, af}]
			}

			function _addCube(x, y, z, af, g = 2) {
				return {x, y, z, 'g': g, af};
			}

			// JSOCTA helper function for creating a 3D line of cubes between two points, considering gridpower
			function _jsocta_lineTo(startX, startY, startZ, endX, endY, endZ, g = 2, event = null) {
				const maxDimension = 1024;
				const cubes = [];
				const cubeSize = Math.pow(2, g);  // cube size determined by grid power

				// ensure end coordinates do not exceed the maximum dimension of the world
				endX = Math.min(endX, maxDimension);
				endY = Math.min(endY, maxDimension);
				endZ = Math.min(endZ, maxDimension);

				// calculate steps needed for each coordinate axis
				const dx = Math.abs(endX - startX);
				const dy = Math.abs(endY - startY);
				const dz = Math.abs(endZ - startZ);
				const xs = startX < endX ? cubeSize : -cubeSize;
				const ys = startY < endY ? cubeSize : -cubeSize;
				const zs = startZ < endZ ? cubeSize : -cubeSize;

				// determine which axis requires the most steps
				const n = Math.max(dx, dy, dz) / cubeSize;

				for (let step = 0; step <= n; step++) {
					// calculate the current position along the line
					const x = startX + xs * step;
					const y = startY + ys * step;
					const z = startZ + zs * step;

					// create cube at current position if within bounds
					if (x < maxDimension && y < maxDimension && z < maxDimension) {
						const cube = { x, y, z, g: cubeSize, af: 2 };  // af: default texture index, modify in event callback if needed

						// if an event is provided, allow modifications to the cube
						if (event) {
							event(cube);
						}
						cubes.push(cube);
					}
				}

				return cubes;
			}

			function _random_array(arr) {
				return arr[Math.floor(Math.random() * arr.length)];
			}
			function _truncate_string(str, minLength) {
				if (str.length <= minLength) {
					return str;
				}

				// calculate the number of characters to show from the start and end
				let partLength = Math.floor(minLength / 3);
				let start = str.substring(0, partLength);
				let end = str.substring(str.length - partLength);
				
				return `${start}...${end}`;
			}

			function _fix_link_redirect(element) { // websim workaround (otherwise it will try to generate the page instead of redirecting to it)
				if (window.parent && window.parent !== window) {
					window.parent.location.href = element.href;
				}
			}

			function _alert_gif(error, fatal = true) {
				let div_error = document.createElement('div');
				if (fatal) { console.error(error); } else { console.warn(error); }

				// Set styles and icons based on severity
				let icon = fatal ? _icon_fail : _icon_info || 'âš ï¸'; // use your warning icon if you have one
				let color = fatal ? 'red' : 'orange';
				let emoji = fatal ? 'ðŸ˜­' : 'ðŸ˜';
				let title = fatal 
					? `âŒâš ï¸â—<strong style='color: red;'>${_app_name} Failed</strong>âŒâŒâš ï¸`
					: `âš ï¸<strong style='color: orange;'>${_app_name} Warning</strong>âš ï¸`;

				div_error.innerHTML = `
					<img src="${icon}">
					<div style='color: ${color}'>${emoji} ${error}</div>
					${fatal 
						? "If you continue to see this, please refresh the page or try again later."
						: "This issue is not critical. You may continue, but some features may not work as expected.<br><hr><br><img src='https://i.imgur.com/JgC89zE.png' width='512px'>"
					}
				`;
				let error_window = desktop.addWindow(title, div_error, icon, 612, 450, 500, 300);
				error_window.subIcon = fatal ? 'âŒ' : 'âš ï¸';
				error_window.body.style.textAlign = 'center';
				if (!fatal) error_window.body.style.borderColor = 'orange';
			}


			// jsocta worker implemented with a blob due to websim limitations regarding external files:

			const _jsocta_main_string = `
			/*
			Minified JSOCTA - Write Cube 2 Sauerbraten maps using JSON.
			by @SalatielSauer, licensed under ZLIB (https://www.zlib.net/zlib_license.html)
			*/

			class QuickOGZ {
			constructor(object) {
				this.mapsize = object.mapsize || 1024;
				this.mapvars = object.mapvars || { maptitle: "Untitled map by Unknown" };
				this.entities = object.entities || [];
				this.octree = object.geometry || [];
				this.dataTypes = {
				mapvar: ["integer", "float", "string"],
				entity: [
					"none?", "light", "mapmodel", "playerstart", "envmap", "particles", "sound", "spotlight",
					"shells", "bullets", "rockets", "riflerounds", "grenades", "cartridges",
					"health", "healthboost", "greenarmour", "yellowarmour", "quaddamage",
					"teleport", "teledest",
					"monster", "carrot", "jumppad",
					"base", "respawnpoint",
					"box", "barrel",
					"platform", "elevator",
					"flag"
				]
				};
			}

			indexOfEntity(name) {return this.dataTypes.entity.indexOf(name);}

			getString() {
				return \`4f4354412100000024000000\${this._IH(this.mapsize, 4)}\${this._IH(this.entities.length, 4)}000000000000000000000000\${this._IH(Object.keys(this.mapvars).length, 4)}00000000\${this.format_mapvars()}036670730000000000050002000400030005000700\${this.format_entities()}\${this.format_geometry()}\`.replace(/,/g, "");
			}

			getByteArray() {
				return this._HTB(this.getString());
			}

			format_mapvars() {
				return Object.keys(this.mapvars).map((key, index) => {
				let mapvar = {name: key, value: Object.values(this.mapvars)[index]};
				// treats array values as RGB and converts it to decimal
				if (typeof mapvar.value == "object") {
					mapvar.value = this._CTI(mapvar.value);
				};
				mapvar.type = this.getTypeofVar(mapvar.value);
				// int/float: type + name length + name + value
				//   string: type + name length + name + value length + value
				return (
					this._IH(this.dataTypes.mapvar.indexOf(mapvar.type), 1) +
					this._IH(mapvar.name.length, 2) +
					this._STH(mapvar.name) +
					(mapvar.type == "integer"
					? this._IH(mapvar.value, 4)
					: mapvar.type == "float"
					? this._FTH(mapvar.value)
					: this._IH(mapvar.value.length, 2) + this._STH(mapvar.value))
				);
				});
			}

			format_entities() {
				return this.entities.map((entity) => \`\${this._FTH(entity.x||0)}\${this._FTH(entity.y||0)}\${this._FTH(entity.z||0)}\${this._IH(entity.at0||0, 2)}\${this._IH(entity.at1||0, 2)}\${this._IH(entity.at2||0, 2)}\${this._IH(entity.at3||0, 2)}\${this._IH(entity.at4||0, 2)}\${this._IH(entity.t||0, 2)}\`);
			}

			format_geometry() {
				let octree = new Array(8).fill({t: 1});
				let cubes = this.octree;
				let mapsize = this.mapsize;
				let _IH = this._IH;
				function subdivide(item, root = 0) {
				if (Array.isArray(item)) {
					item = item.concat(Array(8 - item.length).fill({t: 1})); // fills undefined children with empty cubes
					if (!root) {
					item.splice(0, 0, {t: 0}); // inserts children indicator
					}
					return item.map((item) => subdivide(item)); // reads children recursively
				}
				let cube = item || {t: 1};
				return \`0\${cube.t==0 ? "0" : \`\${cube.t==1 ? "1" : \`3\${8-cube.bk3||8}\${cube.ft2||0}\${8-cube.bk2||8}\${cube.ft3||0}\${8-cube.bk1||8}\${cube.ft0||0}\${8-cube.bk0||8}\${cube.ft1||0}\${8-cube.rt2||8}\${cube.lf3||0}\${8-cube.rt0||8}\${cube.lf1||0}\${8-cube.rt3||8}\${cube.lf2||0}\${8-cube.rt1||8}\${cube.lf0||0}\${8-cube.tp2||8}\${cube.dn0||0}\${8-cube.tp0||8}\${cube.dn2||0}\${8-cube.tp3||8}\${cube.dn1||0}\${8-cube.tp1||8}\${cube.dn3||0}\`}\${_IH(cube.lf||cube.af||1, 2)}\${_IH(cube.rt||cube.af||1, 2)}\${_IH(cube.bk||cube.af||1, 2)}\${_IH(cube.ft||cube.af||1, 2)}\${_IH(cube.dn||cube.af||1, 2)}\${_IH(cube.tp||cube.af||1, 2)}\`}\`;
				}

				function insert(type, x=0, y=0, z=0, gridpower) {
				let base_gridpower = (Math.log2(mapsize) | 0) - 1;
				let level_difference = base_gridpower - gridpower;
				function insert_cube(tree, idx, level) {
					if (level === 0) {
					tree[idx] = type;
					return;
					}
					const powValue = Math.pow(2, 3 * level);
					let child_idx = Math.floor(idx / powValue);
					if (tree[child_idx] == {t: 1}) {
					tree[child_idx] = Array(8).fill({t: 1});
					} else {
					if (Array.isArray(tree[child_idx])) {
						// handles the situation where a cube is added into an existing subdivision that does not have all children defined yet
						tree[child_idx] = tree[child_idx].concat(Array(8 - tree[child_idx].length).fill({t: 1}));
					} else {
						// handles existing neighboring cubes by copying their parent's original properties when subdividing,
						// has visible effect when trying to edit over a modified edge using a different gridpower
						tree[child_idx] = Array(8).fill(tree[child_idx] || {t: 1});
					}
					}
					insert_cube(tree[child_idx], idx % powValue, level - 1);
				}
				let tree = octree.slice(0, 8);
				let index = \`\${parseInt((x / (1 << gridpower)).toString(2), 8)+parseInt((y / (1 << gridpower)).toString(2), 8) * 2+parseInt((z / (1 << gridpower)).toString(2), 8) * 4}\`;
				insert_cube(tree, index, level_difference);
				return tree;
				}

				cubes.forEach(cube => {
				octree = insert(cube, cube.x||0, cube.y||0, cube.z||0, cube.g||0);
				});
				
				return subdivide(octree, 1);
			}

			_FTH(val) {
				const getHex = i => \`00\${i.toString(16)}\`.slice(-2);
				const view = new DataView(new ArrayBuffer(4));
				view.setFloat32(0, val);
				return Array.apply(null, {length: 4}).map((_, i) => getHex(view.getUint8(i))).reverse().join("");
			}
			_IH(val, byte) {
				val = parseInt(val).toString(16).padStart(byte * 2, '0');
				let result = '';
				for (let i = 0; i < byte * 2; i += 2) {
				result = val.substr(i, 2) + result;
				}
				return result;
			}
			_HTB(val) {
				const length = val.length / 2;
				const result = new Uint8Array(length);
				for (let i = 0; i < length; i++) {
				result[i] = parseInt(val.substr(i * 2, 2), 16);
				}
				return result;
			}
			//_STH(val) {return val.split("").reduce((hex,c)=>hex+=c.charCodeAt(0).toString(16).padStart(2,"0"),"");}
			_STH(val) {
				let hex = '';
				for (const c of val) {
				hex += c.charCodeAt(0).toString(16).padStart(2, "0");
				}
				return hex;
			}
			_CTI(array) {return array[0] * (256*256) + array[1] * 256 + array[2];}
			_CTH(array) {return ((1 << 24) + (array[0] << 16) + (array[1] << 8) + array[2]).toString(16).slice(1);}
			_CTSH(array) {return "0x" + this._CTH([Math.round(array[0]/17), Math.round(array[1]/17), Math.round(array[2]/17)]).slice(1).replace(/(.{1})./g, "$1").toUpperCase();}
			getTypeofVar(val) {return ((typeof val) == "number") ? (val == 0 || val%1 == 0) ? "integer" : "float" : "string";}
			}
			`;

			// create blob for main JSOCTA script
			const _jsocta_main_blob = new Blob([_jsocta_main_string], { type: 'application/javascript' });
			const _jsocta_main_url = URL.createObjectURL(_jsocta_main_blob);

			const _jsocta_worker_string = `
			importScripts('https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js', '${_jsocta_main_url}');

			function getJSOCTAVersion(object) {
			switch(object.version || 2) {
				case 1: return OctaMap;
				case 2: return QuickOGZ;
			};
			}

			function isAlreadyObject(content) {
				return typeof content === 'object' && content !== null && !Array.isArray(content);
			}

			const _jsocta_current_file = {};
			self.onmessage = async (event) => {
			let message = event.data;
			let skipInitialization = false;

			switch(message.type) {
				case 1:
					if (_jsocta_current_file.JSOCTA.mapsize >= 65536) {
						postMessage({'type': -1, 'body': {'error': "Out-of-bounds cubes are beyond predefined limit (65536 units).", _jsocta_current_file}});
						return;
					}
					// prevents RangeError when trying to add cubes outside the map boundaries
					_jsocta_current_file.JSOCTA.mapsize *= 2;
					skipInitialization = true;
				case 0:
					try {
						if (!skipInitialization) {
							postMessage({'type': 0, 'body': 'Reading JSON data..'});
							if (!isAlreadyObject(message.body.content)) {
								_jsocta_current_file.JSON = JSON.parse(message.body.content.replace(/,\s*([\]}])/g, '$1'));
							} else {
								_jsocta_current_file.JSON = message.body.content;
							}

							let JSOCTA = getJSOCTAVersion(_jsocta_current_file.JSON);

							postMessage({'type': 0, 'body': 'Writing OGZ data..'});
							_jsocta_current_file.JSOCTA = new JSOCTA(_jsocta_current_file.JSON.map || _jsocta_current_file.JSON);
						}
						//console.time("WrittingOGZ");
						let OCT = _jsocta_current_file.JSOCTA.getByteArray();
						//console.timeEnd("WrittingOGZ");
						postMessage({'type': 0, 'body': 'Compressing OGZ data..'});
						_jsocta_current_file.GZIP = pako.gzip(OCT);
						
						postMessage({'type': 1, 'body': {'_jsocta_current_file': _jsocta_current_file}});
					} catch (error) {
						postMessage({'type': -1, 'body': {error, _jsocta_current_file}});
					}
					break;
			}
			};
			`;

			// create blob for JSOCTA worker script
			const _jsocta_worker_string_blob = new Blob([_jsocta_worker_string], { type: 'application/javascript' });
			const _jsocta_worker_string_url = URL.createObjectURL(_jsocta_worker_string_blob);
			const _jsocta_worker = new Worker(_jsocta_worker_string_url);

			class fileStatus {
				constructor () {}
				update(state, message) {
					console.log(state, message);
				}
			}
			const FS_fileStatus = new fileStatus(); // lazy implementation

			let _jsocta_current_file = {};
			const _jsocta_gzip_history = [];

			_jsocta_worker.onmessage = function(event) {
				const message = event.data;
				_jsocta_current_file = message.body._jsocta_current_file;
				switch(message.type) {
					case -1:
						if (message.body.error.toString().includes('RangeError')) {
							FS_fileStatus.update(1, `Trying to adjust mapsize to contain out-of-bounds cubes.. ${message.body._jsocta_current_file.JSOCTA.mapsize}`, 'fas fa-spinner fa-spin');
							_jsocta_worker.postMessage({'type': 1});
							_jsocta_worker.log(`Trying to fix out-of-bounds cubes with mapsize ${message.body._jsocta_current_file.JSOCTA.mapsize*2}..`)
						} else {
							console.error('Could not parse JSON correctly.', message.body);
							FS_fileStatus.update(0, `Something went wrong.`, 'fas fa-times');
							_jsocta_worker.error(message.body);
						}
						break;
					case 0:
						FS_fileStatus.update(1, `${message.body}`, 'fas fa-spinner fa-spin');
						_jsocta_worker.log(message.body)
						break;
					case 1:
						_jsocta_current_file = message.body._jsocta_current_file;
						FS_fileStatus.update(0, `Done, OGZ file is ready.`, 'fas fa-check-circle');
						_jsocta_gzip_history.push(_jsocta_current_file.GZIP);

						if ('callback' in _jsocta_worker) {
							_jsocta_worker.callback(_jsocta_current_file);
							_jsocta_worker.callback = () => {};
						}
						break;
				}
			};

			function _jsocta_jsonToOGZ(string, log, done, error) {
				_jsocta_worker.postMessage({'type': 0, 'body': {'content': string}});
				_jsocta_worker.log = log ? log : ()=>{};
				_jsocta_worker.callback = done ? done : ()=>{};
				_jsocta_worker.error = error ? error : (error)=>{alert(error)};
			}

			function _josias_openWithLoopfiles(path, e) {
				saueracle_explorer.openFolder(path);
				_loopfiles_open(e, _icon_folder);
			}

			function _josias_download_ogz(id) {
				const blob = new Blob([_jsocta_gzip_history[id]], { type: 'application/gzip' });
				const url = URL.createObjectURL(blob);
				const link = document.createElement('a');
				link.href = url;

				const date = new Date();
				const dateString = date.toISOString().split('T')[0];
				link.download = `saueracle_map_${dateString}.ogz`;

				link.click();
				URL.revokeObjectURL(url);
			}

			function _loopfiles_generateFile(path, description, event, ondone = () => {}) {
				//event.stopPropagation();
				saueracle_explorer.pushFile(`${path}`, '', 'file content must match the context: ' + description);
				ondone();

				// remove filename and last / before opening the folder
				//saueracle_explorer.openFolder(path.replace(/\/[^/]+$/, ''));

				// find generated file and click it
				const file = saueracle_explorer.currentContext.find(f => f.name === path.split('/').pop());
				if (file) { file.element.click() } else {
					console.warn(`File ${path} not created in current context.`);
				}
			}

			function _download_file(name, content, type = 'application/gzip') {
				const blob = new Blob([content], { type: type });
				const url = URL.createObjectURL(blob);
				const link = document.createElement('a');
				link.href = url;

				link.download = `${name}`;

				link.click();
				URL.revokeObjectURL(url);
			}

			function _addText(text, startX, startY, startZ, textureIndex = 2, gridPower = 0, rotate = 0) {
				const charWidth = 5; // assuming each character is 5 cubes wide
				const charHeight = 7; // assuming each character is 7 cubes tall
				const spacing = 1; // space between characters
				const verticalSpacing = 2; // vertical space between lines
				const tabSize = 2; // equivalent to 4 characters wide
				const cubeSize = Math.pow(2, gridPower);
				const initialX = startX; // to reset startX on newline
				const map = [];
				let mirror = false;

				for (let i = 0; i < text.length; i++) {
					let c = mirror ? ((text.length-1) - i) : i; // tofix: last letter gets lost
					const character = text[c];

					if (character === ' ') {
						startX += (charWidth + spacing) * cubeSize; // move start position for space
						continue;
					} else if (character === '\n') {
						startX = initialX; // reset to beginning of line
						startZ -= (charHeight + verticalSpacing) * cubeSize; // move down a line
						continue;
					} else if (character === '\t') {
						startX += (charWidth * tabSize + spacing) * cubeSize; // move start position for tab
						continue;
					}

					const matrix = _jsocta_text_get_matrix(character);
					for (let y = 0; y < matrix.length; y++) {
						for (let x = 0; x < matrix[y].length; x++) {
							let matrix_block = mirror ? matrix[y][matrix[y].length - 1 - x] : matrix[y][x];
							if (matrix_block === 1) {
								let cube = {
									x: startX + x * cubeSize,
									y: startY,
									z: startZ + (charHeight - y) * cubeSize,
									g: gridPower,
									af: textureIndex
								}
								switch(rotate) {
									case 1: case 3:
										let temp = cube.x;
										cube.x = cube.y;
										cube.y = temp;
										if (rotate == 3) {
											mirror = true;
										}
										break;
									case 2:
										mirror = true;
										break;
									default: 
										break;
								}
								map.push(cube);
							}
						}
					}
					startX += (charWidth + spacing) * cubeSize; // move start position to next character

				}

				return map;
			}

			function _jsocta_text_get_matrix(char) {
				return _jsocta_char_matrices[char.toUpperCase()] || _jsocta_char_matrices[' '];
			}

			const _jsocta_char_matrices={
				" ":[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],A:[[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],B:[[1,1,1,0,0],[1,0,0,1,0],[1,1,1,0,0],[1,0,0,1,0],[1,0,0,1,0],[1,0,0,1,0],[1,1,1,0,0]],C:[[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,1],[0,1,1,1,0]],D:[[1,1,1,0,0],[1,0,0,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,1,0],[1,1,1,0,0]],E:[[1,1,1,1,1],[1,0,0,0,0],[1,1,1,0,0],[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],F:[[1,1,1,1,1],[1,0,0,0,0],[1,1,1,0,0],[1,1,1,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]],G:[[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],H:[[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],I:[[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1]],J:[[0,0,0,1,1],[0,0,0,1,1],[0,0,0,1,1],[0,0,0,1,1],[1,0,0,1,1],[1,0,0,1,1],[0,1,1,0,0]],K:[[1,0,0,0,1],[1,0,0,1,0],[1,0,1,0,0],[1,1,0,0,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]],L:[[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],M:[[1,0,0,0,1],[1,1,0,1,1],[1,0,1,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],N:[[1,0,0,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],O:[[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],P:[[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]],Q:[[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,1,1],[1,0,1,0,1],[1,1,0,1,0],[0,1,1,1,1]],R:[[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]],S:[[0,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[0,1,1,1,0],[0,0,0,0,1],[0,0,0,0,1],[1,1,1,1,0]],T:[[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],U:[[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],V:[[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0]],W:[[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,1,0,1],[1,1,0,1,1],[1,0,0,0,1],[1,0,0,0,1]],X:[[1,0,0,0,1],[0,1,0,1,0],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]],Y:[[1,0,0,0,1],[0,1,0,1,0],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],Z:[[1,1,1,1,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],0:[[0,1,1,1,0],[1,0,0,0,1],[1,0,1,0,1],[1,0,1,0,1],[1,0,1,0,1],[1,0,0,0,1],[0,1,1,1,0]],1:[[0,0,1,0,0],[0,1,1,0,0],[1,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1]],2:[[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,1,1,1,1]],3:[[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,1,1,0],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],4:[[0,0,0,1,0],[0,0,1,1,0],[0,1,0,1,0],[1,0,0,1,0],[1,1,1,1,1],[0,0,0,1,0],[0,0,0,1,0]],5:[[1,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],6:[[0,0,1,1,0],[0,1,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],7:[[1,1,1,1,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],8:[[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],9:[[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,1],[0,0,0,0,1],[0,0,0,1,0],[1,1,1,0,0]],"/": [[0,0,0,0,1],[0,0,0,1,0],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[0,1,0,0,0],[1,0,0,0,0]],"[": [[0,1,1,1,0],[0,1,0,0,0],[0,1,0,0,0],[0,1,0,0,0],[0,1,0,0,0],[0,1,0,0,0],[0,1,1,1,0]],"]": [[0,1,1,1,0],[0,0,0,1,0],[0,0,0,1,0],[0,0,0,1,0],[0,0,0,1,0],[0,0,0,1,0],[0,1,1,1,0]],")": [[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,1,0],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0]],"(": [[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[0,1,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0]],"}": [[1,1,0,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,0,0,0]],"{": [[0,0,0,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,1,1]],"=": [[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0]],">": [[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0]],"<": [[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0]],",": [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0]],":": [[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,1,0,0],[0,0,1,0,0]],"\"": [[0,1,0,1,0],[0,1,0,1,0],[0,1,0,1,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],";": [[0,0,0,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,1,0,0],[0,1,0,0,0]],"*": [[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],".": [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,1,0,0],[0,0,1,0,0]],"$": [[0,0,0,1,0],[1,1,1,1,1],[1,0,1,0,0],[1,1,1,1,1],[0,0,1,0,1],[1,1,1,1,1],[0,1,0,0,0]],"_": [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[1,1,1,1,1]],"\`": [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],"@": [[0,1,1,1,0],[1,0,0,0,1],[1,0,1,1,1],[1,0,1,1,0],[1,0,0,0,0],[1,1,0,0,1],[0,1,1,1,0]],"+": [[0,0,0,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0]],
			};

		</script>
	</body>
</html>
